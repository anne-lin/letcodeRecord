/**
 * Created by panfei on 2016/8/29.
 */
define('jquery',[], function() {return window.jQuery});

/**
 * 默认数据设置
 */
define('wa_Defaults',[], function() {
    "use strict";

    return {

        //电话图标距屏幕右方、下方的距离
        iconRight: 10,
        iconBottom: 250,

        //登录界面相对电话图标右方、下方的距离
        relativeRight: 42,
        relativeBottom: -210,

        //电话图标的颜色
        iconColor: "#f80"
    };
});
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define('wa_io',[],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

module.exports = _dereq_('./lib/');

},{"./lib/":2}],2:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var parser = _dereq_('socket.io-parser');
var Manager = _dereq_('./manager');
var debug = _dereq_('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = (cache[id] && cache[id].nsps[path] &&
                       path == cache[id].nsps[path].nsp);
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = _dereq_('./manager');
exports.Socket = _dereq_('./socket');

},{"./manager":3,"./socket":5,"./url":6,"debug":10,"socket.io-parser":46}],3:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var url = _dereq_('./url');
var eio = _dereq_('engine.io-client');
var Socket = _dereq_('./socket');
var Emitter = _dereq_('component-emitter');
var parser = _dereq_('socket.io-parser');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var object = _dereq_('object-component');
var debug = _dereq_('debug')('socket.io-client:manager');
var indexOf = _dereq_('indexof');
var Backoff = _dereq_('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":4,"./socket":5,"./url":6,"backo2":7,"component-bind":8,"component-emitter":9,"debug":10,"engine.io-client":11,"indexof":42,"object-component":43,"socket.io-parser":46}],4:[function(_dereq_,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],5:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var parser = _dereq_('socket.io-parser');
var Emitter = _dereq_('component-emitter');
var toArray = _dereq_('to-array');
var on = _dereq_('./on');
var bind = _dereq_('component-bind');
var debug = _dereq_('debug')('socket.io-client:socket');
var hasBin = _dereq_('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":4,"component-bind":8,"component-emitter":9,"debug":10,"has-binary":38,"socket.io-parser":46,"to-array":50}],6:[function(_dereq_,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = _dereq_('parseuri');
var debug = _dereq_('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":10,"parseuri":44}],7:[function(_dereq_,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],8:[function(_dereq_,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],9:[function(_dereq_,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],10:[function(_dereq_,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],11:[function(_dereq_,module,exports){

module.exports =  _dereq_('./lib/');

},{"./lib/":12}],12:[function(_dereq_,module,exports){

module.exports = _dereq_('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = _dereq_('engine.io-parser');

},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = _dereq_('./transports');
var Emitter = _dereq_('component-emitter');
var debug = _dereq_('debug')('engine.io-client:socket');
var index = _dereq_('indexof');
var parser = _dereq_('engine.io-parser');
var parseuri = _dereq_('parseuri');
var parsejson = _dereq_('parsejson');
var parseqs = _dereq_('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.lib client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = _dereq_('./transport');
Socket.transports = _dereq_('./transports');
Socket.parser = _dereq_('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":14,"./transports":15,"component-emitter":9,"debug":22,"engine.io-parser":25,"indexof":42,"parsejson":34,"parseqs":35,"parseuri":36}],14:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var parser = _dereq_('engine.io-parser');
var Emitter = _dereq_('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.lib client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var XHR = _dereq_('./polling-xhr');
var JSONP = _dereq_('./polling-jsonp');
var websocket = _dereq_('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,"xmlhttprequest":20}],16:[function(_dereq_,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = _dereq_('./polling');
var inherit = _dereq_('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = _dereq_('xmlhttprequest');
var Polling = _dereq_('./polling');
var Emitter = _dereq_('component-emitter');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.lib client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.lib client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.lib client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":18,"component-emitter":9,"component-inherit":21,"debug":22,"xmlhttprequest":20}],18:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parseqs = _dereq_('parseqs');
var parser = _dereq_('engine.io-parser');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = _dereq_('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":35,"xmlhttprequest":20}],19:[function(_dereq_,module,exports){
/**
 * Module dependencies.
 */

var Transport = _dereq_('../transport');
var parser = _dereq_('engine.io-parser');
var parseqs = _dereq_('parseqs');
var inherit = _dereq_('component-inherit');
var debug = _dereq_('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = _dereq_('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.lib client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":14,"component-inherit":21,"debug":22,"engine.io-parser":25,"parseqs":35,"ws":37}],20:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = _dereq_('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":40}],21:[function(_dereq_,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],22:[function(_dereq_,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = _dereq_('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":23}],23:[function(_dereq_,module,exports){

/**
 * This is the common logic for both the Node.lib and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = _dereq_('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":24}],24:[function(_dereq_,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],25:[function(_dereq_,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = _dereq_('./keys');
var hasBinary = _dereq_('has-binary');
var sliceBuffer = _dereq_('arraybuffer.slice');
var base64encoder = _dereq_('base64-arraybuffer');
var after = _dereq_('after');
var utf8 = _dereq_('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = _dereq_('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":26,"after":27,"arraybuffer.slice":28,"base64-arraybuffer":29,"blob":30,"has-binary":31,"utf8":33}],26:[function(_dereq_,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],27:[function(_dereq_,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],28:[function(_dereq_,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],29:[function(_dereq_,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],30:[function(_dereq_,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":32}],32:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],33:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.lib or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.lib, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.lib or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],34:[function(_dereq_,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],35:[function(_dereq_,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],36:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],37:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],38:[function(_dereq_,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = _dereq_('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"isarray":39}],39:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],40:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var global = _dereq_('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.lib
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":41}],41:[function(_dereq_,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],42:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],43:[function(_dereq_,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],44:[function(_dereq_,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],45:[function(_dereq_,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = _dereq_('isarray');
var isBuf = _dereq_('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is-buffer":47,"isarray":48}],46:[function(_dereq_,module,exports){

/**
 * Module dependencies.
 */

var debug = _dereq_('debug')('socket.io-parser');
var json = _dereq_('json3');
var isArray = _dereq_('isarray');
var Emitter = _dereq_('component-emitter');
var binary = _dereq_('./binary');
var isBuf = _dereq_('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":45,"./is-buffer":47,"component-emitter":9,"debug":10,"isarray":48,"json3":49}],47:[function(_dereq_,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],48:[function(_dereq_,module,exports){
module.exports=_dereq_(32)
},{}],49:[function(_dereq_,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.lib`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],50:[function(_dereq_,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}]},{},[1])
(1)
});

/**
 * 常量模块
 */
define('wa_Constant',[], function() {
    "use strict";

    /**
     * 状态集
     */
    var states = {
        INIT : { key: "INIT", desc: "初始化" },
        LOGINING : {key: "LOGINING", desc: "登录中"},
        LOGOUT : { key: "LOGOUT", desc: "登出" },
        READY : { key: "READY", desc: "置闲" },
        WORKING : { key: "WORKING", desc: "工作状态" },
        CONNECTING : { key: "CONNECTING", desc: "正在呼叫" },
        AGENT_ALERTING : { key: "AGENT_ALERTING", desc: "坐席振铃"},
        AGENT_CONNECTED : { key: "AGENT_CONNECTED", desc: "坐席接通" },
        CUSTOM_ALERTING : { key: "CUSTOM_ALERTING", desc: "客户振铃" },
        CONNECTED : { key: "CONNECTED", desc: "双方通话" },
        INTERNAL_ALERTING : { key: "INTERNAL_ALERTING", desc: "内呼振铃" },
        INTERNAL_CONNECTED : { key: "INTERNAL_CONNECTED", desc: "内呼接通" },
        ACW : { key: "ACW", desc: "事后整理" },
        BUSY : { key: "BUSY", desc: "置忙" },
        AWAY : { key: "AWAY", desc: "小休" },
        HOLD : { key: "HOLD", desc: "保持" },
        BEHOLD : { key: "BEHOLD", desc: "被保持" },
        CONSULTING : { key: "CONSULTING", desc: "正在咨询" },
        CONSULT_ALERTING : { key: "CONSULT_ALERTING", desc: "咨询振铃" },
        CONSULT_B_ALERTING : { key: "CONSULT_B_ALERTING", desc: "被咨询振铃" },
        CONSULTED : { key: "CONSULTED", desc: "咨询接通" },
        CONSULTED_B : { key: "CONSULTED_B", desc: "被咨询接通" },
        TRANSFERRING : { key: "TRANSFERRING", desc: "正在转移" },
        TRANSFER_ALERTING : { key: "TRANSFER_ALERTING", desc: "转移振铃" },
        CONFERENCING : { key: "CONFERENCING", desc: "正在会议" },
        CONFERENCED : { key: "CONFERENCED", desc: "会议中" },
        OBSERVING : { key: "OBSERVING", desc: "正在监听" },
        OBSERVE_ALERTING : { key: "OBSERVE_ALERTING", desc: "监听振铃" },
        OBSERVED : { key: "OBSERVED", desc: "监听接通" },
        INSERTING : { key: "INSERTING", desc: "正在强插" },
        FORCE_ABORTING : { key: "FORCE_ABORTING", desc: "正在强拆" },
        FULL_ABORTING : { key: "FULL_ABORTING", desc: "正在全拆" },
        MP_CONFERENCING: { key: "MP_CONFERENCING", desc: "正在四方会议" },
        MP_CONFERENCE: { key: "MP_CONFERENCE", desc: "四方会议中" },
        MP_CONFERENCE_ALERTING_OP:{ key: "MP_CONFERENCE", desc: "四方会议振铃" },
        MP_CONFERENCE_ALERTING_TP:{ key: "MP_CONFERENCE_ALERTING_TP", desc: "四方会议振铃" },
        MP_CONFERENCE_OP: { key: "MP_CONFERENCE_OP", desc: "四方会议接通" },
        MP_CONFERENCE_TP : { key: "MP_CONFERENCE_TP", desc: "四方会议接通" },
        CRYPTOLALIA: { key: "CRYPTOLALIA", desc: "密语中" },
        LAUNCH_CRYPTOLALIA: { key: "LAUNCH_CRYPTOLALIA", desc: "发起密语" },
        SINGLE_STEP_CONFERENCE_ALERTING : { key: "SINGLE_STEP_CONFERENCE_ALERTING", desc: "单步会议振铃" },
    };

    /**
     * 命令集
     */
    var commands = {
        LOGIN : "login",
        AUTO_LOGIN : "autoLogin",
        FORCE_LOGIN : "forceLogin",
        LOGOUT : "logout",
        SET_BUSY : "setBusy",
        SET_AWAY : "setAway",
        SET_READY : "setReady",
        SET_WORKING : "sayWorkState",
        MAKE_CALL : "makeCall",
        MAKE_CALL_INTERNAL : "makeCall-Internal",
        HANGUP : "hangup",
        RESET : "reset",
        HOLD : "hold",
        HOLD_RETURN : "holdReturn",
        AGENTGETLIST: "agentGetList",
        CONSULT : "consult",
        CONSULT_RETURN : "consultReturn",
        TRANSFER : "transfer",
        SINGLE_TRANSFER : "singleTransfer",
        OBSERVE : "observe",
        INTERCEPT: "intercept",
        FORCE_INSERT : "forceInsert",
        FORCE_ABORT : "forceAbort",
        FULL_ABORT : "fullAbort",
        CONFERENCE : "conference",
        ASSIST_IVR : "assistIVR",
        ROUTER_TO_IVR : "routerToIvr",
        SET_CALL_DATA : "setCallData",
        GET_CALL_DATA : "getCallData",
        PUSH_VIDEO : "fileBroadcast",
        SINGLE_CONFERENCE:"singleConference",
        SECOND_CALL:"secondCall",
        JOIN_CONFERENCE:"joinConference", // 多人会议发起
        START_CRYPTO:'startCrypto', // 开启密语
        STOP_CRYPTO:'stopCrypto', // 关闭密语
        SWITCH_SKILL_GROUP:'switchSkillGroup', // 切换技能组
    };

    /**
     * 事件集
     */
    var events = {
        EVENT_AGENT_LOGIN : "EVENT_AGENT_LOGIN",            // 登录成功
        EVENT_NETTY_LOGIN_SUCCESS : "EVENT_NETTY_LOGIN_SUCCESS", // Netty方式登录成功（用于已存在http客户端登录的前提下）
        EVENT_AGENT_LOGOUT : "EVENT_AGENT_LOGOUT",          // 登出成功
        EVENT_AGENT_LOGIN_FAIL : "EVENT_AGENT_LOGIN_FAIL",  // 登录失败
        EVENT_AGENT_READY : "EVENT_AGENT_READY",             // 置闲
        EVENT_AGENT_NOTREADY : "EVENT_AGENT_NOTREADY",       // 置忙
        EVENT_AGENT_AWAY : "EVENT_AGENT_AWAY", //小休成功
        EVENT_SET_AWAY_FAIL : "EVENT_SET_AWAY_FAIL", //小休失败
        EVENT_CALL_CONTROL_FAIL : "EVENT_CALL_CONTROL_FAIL",    // 话路控制失败
        EVENT_OUTBOUND_ALERTING_TP : "EVENT_OUTBOUND_ALERTING_TP", // 外呼坐席振铃
        EVENT_OUTBOUND_CONNECTED_TP : "EVENT_OUTBOUND_CONNECTED_TP", // 外呼坐席接通
        EVENT_OUTBOUND_ALERTING_OP : "EVENT_OUTBOUND_ALERTING_OP",  // 外呼客户振铃
        EVENT_OUTBOUND_CONNECTED_OP : "EVENT_OUTBOUND_CONNECTED_OP", // 外呼客户接通
        EVENT_TP_DISCONNECT : "EVENT_TP_DISCONNECT",                 // 坐席挂断
        EVENT_OP_DISCONNECT : "EVENT_OP_DISCONNECT",                 //客户挂断
        EVENT_INBOUND_ALERTING : "EVENT_INBOUND_ALERTING",          // 呼入坐席振铃事件
        EVENT_INBOUND_CONNECTED : "EVENT_INBOUND_CONNECTED",           // 呼入坐席接通事件
        EVENT_INTERNAL_ALERTING_TP : "EVENT_INTERNAL_ALERTING_TP",       // 内呼坐席振铃事件(发起内呼坐席)
        EVENT_INTERNAL_CONNECTED_TP : "EVENT_INTERNAL_CONNECTED_TP",    // 内呼坐席接通事件(发起内呼坐席)
        EVENT_INTERNAL_ALERTING_OP : "EVENT_INTERNAL_ALERTING_OP",      // 内呼坐席振铃事件(被内呼坐席)
        EVENT_INTERNAL_CONNECTED_OP : "EVENT_INTERNAL_CONNECTED_OP",       // 内呼坐席接通事件(被内呼坐席)
        EVENT_AGENT_HOLD : "EVENT_AGENT_HOLD",                       // 坐席保持
        EVENT_HOLD_RETRIEVE : "EVENT_HOLD_RETRIEVE",                 // 坐席保持接回
        EVENT_CONSULT_ALTERTING_OP : "EVENT_CONSULT_ALTERTING_OP",     // 咨询坐席振铃事件(发起咨询坐席)
        EVENT_CONSULT_CONNECTED_OP : "EVENT_CONSULT_CONNECTED_OP",    // 咨询坐席接通事件(发起咨询坐席)
        EVENT_CONSULT_RETRIEVE : "EVENT_CONSULT_RETRIEVE",               // 咨询接回事件
        EVENT_CONSULT_FAIL : "EVENT_CONSULT_FAIL",                      // 咨询失败
        EVENT_TRANSFER : "EVENT_TRANSFER",                               // 转移事件
        EVENT_SINGLE_STEP_TRANSFER_ALERTING_TP : "EVENT_SINGLE_STEP_TRANSFER_ALERTING_TP", // 单步转移振铃事件(目标坐席)
        EVENT_SINGLE_STEP_TRANSFER_CONNECTED_TP : "EVENT_SINGLE_STEP_TRANSFER_CONNECTED_TP", // 单步转移接通事件(目标坐席)
        EVENT_CONSULT_ALERTING_TP : "EVENT_CONSULT_ALERTING_TP",         // 咨询坐席振铃事件(被咨询坐席)
        EVENT_CONSULT_CONNECTED_TP : "EVENT_CONSULT_CONNECTED_TP",      // 咨询坐席接通事件(被咨询坐席)
        EVENT_MONITOR_ALERTING : "EVENT_MONITOR_ALERTING",               // 监听振铃事件
        EVENT_MONITOR : "EVENT_MONITOR",                                  // 监听接通事件
        EVENT_MONITOR_FAIL : "EVENT_MONITOR_FAIL",                          // 监听失败
        EVENT_FORCE_CONNECT : "EVENT_FORCE_CONNECT",                      // 强插事件
        EVENT_INTRUDE_FAIL : "EVENT_INTRUDE_FAIL",                          // 强插失败
        EVENT_CLEAR_CALL : "EVENT_CLEAR_CALL",                               // 全拆事件
        EVENT_FORCE_DROP_SUCCESS : "EVENT_FORCE_DROP_SUCCESS",                               // 强拆事件
        EVENT_FORCE_DROP_FAIL : "EVENT_FORCE_DROP_FAIL",                    // 强拆失败
        EVENT_CONFERENCE : "EVENT_CONFERENCE",                               // 会议事件
        EVENT_QUIT_MONITOR_SUCCESS : "EVENT_QUIT_MONITOR_SUCCESS",           // 监听退出/强插退出
        EVENT_AGENT_ACW : "EVENT_AGENT_ACW",                                 // 事后整理
        EVENT_AGENT_BEHOLD : "EVENT_AGENT_BEHOLD",                            // 坐席被保持（客户转IVR协助）
        EVENT_AGENT_BEUNHOLD : "EVENT_AGENT_BEUNHOLD",                       // 坐席被保持接回（客户从IVR转回通话）
        EVENT_GET_ASSOCIATE_DATA : "EVENT_GET_ASSOCIATE_DATA",               // 获取随路数据返回事件
        EVENT_SET_ASSOCIATE_DATA : "EVENT_SET_ASSOCIATE_DATA",               // 设置随路数据返回事件
        EVENT_AGENT_GET_LIST: "EVENT_AGENT_GET_LIST",                       //获得坐席列表
        EVENT_SOCKET_ABNORMAL_DISCONNECT: "EVENT_SOCKET_ABNORMAL_DISCONNECT", //socket异常断开事件，不是agentproxy返回，根据socket事件自定义的事件
        EVENT_SOCKET_RECONNECTING: "EVENT_SOCKET_RECONNECTING", //socket正在重连,
        EVENT_AGENT_LOGIN_ROBOT: "EVENT_AGENT_LOGIN_ROBOT", //机器人助手登录成功
        EVENT_AGENT_LOGIN_FAIL_ROBOT: "EVENT_AGENT_LOGIN_FAIL_ROBOT", //机器人助手登录失败
        EVENT_AGENT_NOTREADY_ROBOT: "EVENT_AGENT_NOTREADY_ROBOT", //机器人助手置忙
        EVENT_AGENT_READY_ROBOT: "EVENT_AGENT_READY_ROBOT", //机器人助手置闲
        EVENT_INBOUND_CONNECTED_ROBOT: "EVENT_INBOUND_CONNECTED_ROBOT", //机器人助手接通
        EVENT_MP_CONFERENCE_ALERTING_TP: "EVENT_MP_CONFERENCE_ALERTING_TP", // 多方会议本方振铃事件 接收方：第四方坐席
        EVENT_MP_CONFERENCE_ALERTING_OP: "EVENT_MP_CONFERENCE_ALERTING_OP", // 多方会议对方振铃事件 接收方：处于会议中的所有坐席
        EVENT_MP_CONFERENCE_CONNECTED_TP: "EVENT_MP_CONFERENCE_CONNECTED_TP", // 多方会议本方接通事件 接收方：第四方坐席
        EVENT_MP_CONFERENCE_CONNECTED_OP: "EVENT_MP_CONFERENCE_CONNECTED_OP", // 多方会议对方接通事件 接收方：处于会议中的所有坐席
        EVENT_MP_CONFERENCE_DISCONNECT_TP: "EVENT_MP_CONFERENCE_DISCONNECT_TP",// 多方会议本方挂断事件,挂断坐席
        EVENT_MP_CONFERENCE_DISCONNECT_OP: "EVENT_MP_CONFERENCE_DISCONNECT_OP", // 多方会议对方挂断事件 处于会议中的所有坐席
        EVENT_JOIN_CONFERENCE_FAIL: "EVENT_JOIN_CONFERENCE_FAIL", // 加入会议失败事件 接收方：发起 joinConference 的坐席
        EVENT_STARTCRYPTO: "EVENT_STARTCRYPTO", // 开启密语成功,发起方
        EVENT_BE_STARTCRYPTO: "EVENT_BE_STARTCRYPTO", // 开启密语成功，接收方
        EVENT_STARTCRYPTO_FAIL: "EVENT_STARTCRYPTO_FAIL", // 开启密语失败
        EVENT_STOPCRYPTO: "EVENT_STOPCRYPTO", // 关闭密语成功
        EVENT_STOPCRYPTO_FAIL: "EVENT_STOPCRYPTO_FAIL", // 关闭密语失败
        EVENT_INTERCEPT_FAIL: "EVENT_INTERCEPT_FAIL", // 拦截失败
        EVENT_AGENT_WORKSTATE: "EVENT_AGENT_WORKSTATE", // 设置工作状态成功
        EVENT_SINGLE_STEP_CONFERENCE_ALERTING_OP: "EVENT_SINGLE_STEP_CONFERENCE_ALERTING_OP", // 单步会议对方振铃
        EVENT_SINGLE_STEP_CONFERENCE_ALERTING_TP: "EVENT_SINGLE_STEP_CONFERENCE_ALERTING_TP", // 单步会议本方振铃
        EVENT_SINGLE_STEP_CONFERENCE_CONNECTED_OP: "EVENT_SINGLE_STEP_CONFERENCE_CONNECTED_OP", // 单步会议对方接通
        EVENT_SINGLE_STEP_CONFERENCE_CONNECTED_TP: "EVENT_SINGLE_STEP_CONFERENCE_CONNECTED_TP", // 单步会议本方接通
        EVENT_SINGLE_STEP_CONFERENCE_FAIL: "EVENT_SINGLE_STEP_CONFERENCE_FAIL", // 单步会议失败
        EVENT_SWTCH_SKILLGROUP_SUCCESS: "EVENT_SWTCH_SKILLGROUP_SUCCESS", // 技能组切换成功
        EVENT_SWTCH_SKILLGROUP_FAIL: "EVENT_SWTCH_SKILLGROUP_FAIL", // 技能组切换失败
        
    };

    return {
        states: states,
        commands: commands,
        events: events
    }
});

/**
 * 日志打印模块
 */
define('wa_Log',[], function() {
    "use strict";

    var print = function(message, level) {
        if (window.console && window.console[level]) {
            window.console[level]("[webAgent-wa]",new Date().toLocaleString() + message);
            if(WebAgent.canWriteLog){
                WebAgent.ButelAjax && WebAgent.ButelAjax.ajaxFunc("WriteLogToLocal", "writeLogToLocal", "&loglevel=" + level + "&logmsg=[webAgent-wa]" + message);
            }
        }
    };

    return {
        log : function(message) {
            print(message, "log");
        },
        info : function(message) {
            print(message, "info");
        },
        warn : function(message) {
            print(message, "warn");
        },
        error : function(message) {
            print(message, "error");
        }
    };
});

/*!
 * Knockout JavaScript library v3.4.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var x=this||(0,eval)("this"),u=x.document,M=x.navigator,v=x.jQuery,F=x.JSON;(function(n){"function"===typeof define&&define.amd?define('knockout',["exports","require"],n):"object"===typeof exports&&"object"===typeof module?n(module.exports||exports):n(x.ko={})})(function(N,O){function J(a,c){return null===a||typeof a in T?a===c:!1}function U(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function V(b,c){var d;return function(){clearTimeout(d);d=a.a.setTimeout(b,c)}}function W(a,
c){c&&c!==I?"beforeChange"===c?this.Kb(a):this.Ha(a,c):this.Lb(a)}function X(a,c){null!==c&&c.k&&c.k()}function Y(a,c){var d=this.Hc,e=d[s];e.R||(this.lb&&this.Ma[c]?(d.Pb(c,a,this.Ma[c]),this.Ma[c]=null,--this.lb):e.r[c]||d.Pb(c,a,e.s?{ia:a}:d.uc(a)))}function K(b,c,d,e){a.d[b]={init:function(b,g,k,l,m){var h,r;a.m(function(){var q=a.a.c(g()),p=!d!==!q,A=!r;if(A||c||p!==h)A&&a.va.Aa()&&(r=a.a.ua(a.f.childNodes(b),!0)),p?(A||a.f.da(b,a.a.ua(r)),a.eb(e?e(m,q):m,b)):a.f.xa(b),h=p},null,{i:b});return{controlsDescendantBindings:!0}}};
a.h.ta[b]=!1;a.f.Z[b]=!0}var a="undefined"!==typeof N?N:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.G=function(a,c,d){a[c]=d};a.version="3.4.0";a.b("version",a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1};a.a=function(){function b(a,b){for(var c in a)a.hasOwnProperty(c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)b.hasOwnProperty(c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var h=b[c].match(r)||
[];a.a.q(d.match(r),function(b){a.a.pa(h,b,e)});b[c]=h.join(" ")}var f={__proto__:[]}instanceof Array,g="function"===typeof Symbol,k={},l={};k[M&&/Firefox\/2/i.test(M.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];k.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(k,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)l[b[c]]=a});var m={propertychange:!0},h=u&&function(){for(var a=3,b=u.createElement("div"),c=
b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),r=/\S+/g;return{cc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],q:function(a,b){for(var c=0,d=a.length;c<d;c++)b(a[c],c)},o:function(a,b){if("function"==typeof Array.prototype.indexOf)return Array.prototype.indexOf.call(a,b);for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Sb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d))return a[d];
return null},La:function(b,c){var d=a.a.o(b,c);0<d?b.splice(d,1):0===d&&b.shift()},Tb:function(b){b=b||[];for(var c=[],d=0,e=b.length;d<e;d++)0>a.a.o(c,b[d])&&c.push(b[d]);return c},fb:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)c.push(b(a[d],d));return c},Ka:function(a,b){a=a||[];for(var c=[],d=0,e=a.length;d<e;d++)b(a[d],d)&&c.push(a[d]);return c},ra:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},pa:function(b,c,d){var e=
a.a.o(a.a.zb(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},ka:f,extend:c,Xa:d,Ya:f?d:c,D:b,Ca:function(a,b){if(!a)return a;var c={},d;for(d in a)a.hasOwnProperty(d)&&(c[d]=b(a[d],d,a));return c},ob:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},jc:function(b){b=a.a.V(b);for(var c=(b[0]&&b[0].ownerDocument||u).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.$(b[d]));return c},ua:function(b,c){for(var d=0,e=b.length,h=[];d<e;d++){var m=b[d].cloneNode(!0);h.push(c?a.$(m):m)}return h},
da:function(b,c){a.a.ob(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},qc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],h=e.parentNode,m=0,l=c.length;m<l;m++)h.insertBefore(c[m],e);m=0;for(l=d.length;m<l;m++)a.removeNode(d[m])}},za:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),
c=c.nextSibling;a.push(d)}}return a},sc:function(a,b){7>h?a.setAttribute("selected",b):a.selected=b},$a:function(a){return null===a||a===n?"":a.trim?a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},nd:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},Mc:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(3===a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=
b;)a=a.parentNode;return!!a},nb:function(b){return a.a.Mc(b,b.ownerDocument.documentElement)},Qb:function(b){return!!a.a.Sb(b,a.a.nb)},A:function(a){return a&&a.tagName&&a.tagName.toLowerCase()},Wb:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Wb(b),c)},$b:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},p:function(b,c,d){var e=a.a.Wb(d);d=h&&m[c];if(a.options.useOnlyNativeEvents||
d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var l=function(a){e.call(b,a)},f="on"+c;b.attachEvent(f,l);a.a.F.oa(b,function(){b.detachEvent(f,l)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else v(b).bind(c,e)},Da:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.A(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==
d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof u.createEvent)if("function"==typeof b.dispatchEvent)d=u.createEvent(l[c]||"HTMLEvents"),d.initEvent(c,!0,!0,x,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");else v(b).trigger(c)},c:function(b){return a.H(b)?
b():b},zb:function(b){return a.H(b)?b.t():b},bb:function(b,c,d){var h;c&&("object"===typeof b.classList?(h=b.classList[d?"add":"remove"],a.a.q(c.match(r),function(a){h.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},Za:function(b,c){var d=a.a.c(c);if(null===d||d===n)d="";var e=a.f.firstChild(b);!e||3!=e.nodeType||a.f.nextSibling(e)?a.f.da(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Rc(b)},rc:function(a,b){a.name=b;if(7>=h)try{a.mergeAttributes(u.createElement("<input name='"+
a.name+"'/>"),!1)}catch(c){}},Rc:function(a){9<=h&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},Nc:function(a){if(h){var b=a.style.width;a.style.width=0;a.style.width=b}},hd:function(b,c){b=a.a.c(b);c=a.a.c(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},V:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Yb:function(a){return g?Symbol(a):a},rd:6===h,sd:7===h,C:h,ec:function(b,c){for(var d=a.a.V(b.getElementsByTagName("input")).concat(a.a.V(b.getElementsByTagName("textarea"))),
e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},h=[],m=d.length-1;0<=m;m--)e(d[m])&&h.push(d[m]);return h},ed:function(b){return"string"==typeof b&&(b=a.a.$a(b))?F&&F.parse?F.parse(b):(new Function("return "+b))():null},Eb:function(b,c,d){if(!F||!F.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return F.stringify(a.a.c(b),c,d)},fd:function(c,d,e){e=e||{};var h=e.params||{},m=e.includeFields||this.cc,l=c;if("object"==typeof c&&"form"===a.a.A(c))for(var l=c.action,f=m.length-1;0<=f;f--)for(var g=a.a.ec(c,m[f]),k=g.length-1;0<=k;k--)h[g[k].name]=g[k].value;d=a.a.c(d);var r=u.createElement("form");r.style.display="none";r.action=l;r.method="post";for(var n in d)c=u.createElement("input"),c.type="hidden",c.name=n,c.value=a.a.Eb(a.a.c(d[n])),r.appendChild(c);b(h,function(a,b){var c=u.createElement("input");
c.type="hidden";c.name=a;c.value=b;r.appendChild(c)});u.body.appendChild(r);e.submitter?e.submitter(r):r.submit();setTimeout(function(){r.parentNode.removeChild(r)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.q);a.b("utils.arrayFirst",a.a.Sb);a.b("utils.arrayFilter",a.a.Ka);a.b("utils.arrayGetDistinctValues",a.a.Tb);a.b("utils.arrayIndexOf",a.a.o);a.b("utils.arrayMap",a.a.fb);a.b("utils.arrayPushAll",a.a.ra);a.b("utils.arrayRemoveItem",a.a.La);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",
a.a.cc);a.b("utils.getFormFields",a.a.ec);a.b("utils.peekObservable",a.a.zb);a.b("utils.postJson",a.a.fd);a.b("utils.parseJson",a.a.ed);a.b("utils.registerEventHandler",a.a.p);a.b("utils.stringifyJson",a.a.Eb);a.b("utils.range",a.a.hd);a.b("utils.toggleDomNodeCssClass",a.a.bb);a.b("utils.triggerEvent",a.a.Da);a.b("utils.unwrapObservable",a.a.c);a.b("utils.objectForEach",a.a.D);a.b("utils.addOrRemoveItem",a.a.pa);a.b("utils.setTextContent",a.a.Za);a.b("unwrap",a.a.c);Function.prototype.bind||(Function.prototype.bind=
function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.e=new function(){function a(b,g){var k=b[d];if(!k||"null"===k||!e[k]){if(!g)return n;k=b[d]="ko"+c++;e[k]={}}return e[k]}var c=0,d="__ko__"+(new Date).getTime(),e={};return{get:function(c,d){var e=a(c,!1);return e===n?n:e[d]},set:function(c,d,e){if(e!==n||a(c,!1)!==n)a(c,!0)[d]=
e},clear:function(a){var b=a[d];return b?(delete e[b],a[d]=null,!0):!1},I:function(){return c++ +d}}};a.b("utils.domData",a.a.e);a.b("utils.domData.clear",a.a.e.clear);a.a.F=new function(){function b(b,c){var e=a.a.e.get(b,d);e===n&&c&&(e=[],a.a.e.set(b,d,e));return e}function c(d){var e=b(d,!1);if(e)for(var e=e.slice(0),l=0;l<e.length;l++)e[l](d);a.a.e.clear(d);a.a.F.cleanExternalData(d);if(f[d.nodeType])for(e=d.firstChild;d=e;)e=d.nextSibling,8===d.nodeType&&c(d)}var d=a.a.e.I(),e={1:!0,8:!0,9:!0},
f={1:!0,9:!0};return{oa:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},pc:function(c,e){var l=b(c,!1);l&&(a.a.La(l,e),0==l.length&&a.a.e.set(c,d,n))},$:function(b){if(e[b.nodeType]&&(c(b),f[b.nodeType])){var d=[];a.a.ra(d,b.getElementsByTagName("*"));for(var l=0,m=d.length;l<m;l++)c(d[l])}return b},removeNode:function(b){a.$(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a])}}};
a.$=a.a.F.$;a.removeNode=a.a.F.removeNode;a.b("cleanNode",a.$);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.F);a.b("utils.domNodeDisposal.addDisposeCallback",a.a.F.oa);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.F.pc);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},
g=8>=a.a.C;a.a.ma=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else{if((e=v.clean([c],d))&&e[0]){for(var h=e[0];h.parentNode&&11!==h.parentNode.nodeType;)h=h.parentNode;h.parentNode&&h.parentNode.removeChild(h)}}else{(e=d)||(e=u);var h=e.parentWindow||e.defaultView||x,r=a.a.$a(c).toLowerCase(),q=e.createElement("div"),p;p=(r=r.match(/^<([a-z]+)[ >]/))&&f[r[1]]||b;r=p[0];p="ignored<div>"+p[1]+c+p[2]+"</div>";"function"==typeof h.innerShiv?q.appendChild(h.innerShiv(p)):(g&&e.appendChild(q),
q.innerHTML=p,g&&q.parentNode.removeChild(q));for(;r--;)q=q.lastChild;e=a.a.V(q.lastChild.childNodes)}return e};a.a.Cb=function(b,c){a.a.ob(b);c=a.a.c(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ma(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.ma);a.b("utils.setHtml",a.a.Cb);a.M=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.M.lc(c.nodeValue);null!=f&&e.push({Lc:c,cd:f})}else if(1==c.nodeType)for(var f=
0,g=c.childNodes,k=g.length;f<k;f++)b(g[f],e)}var c={};return{wb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},xc:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),
!0}finally{delete c[a]}},yc:function(c,e){var f=[];b(c,f);for(var g=0,k=f.length;g<k;g++){var l=f[g].Lc,m=[l];e&&a.a.ra(m,e);a.M.xc(f[g].cd,m);l.nodeValue="";l.parentNode&&l.parentNode.removeChild(l)}},lc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.M);a.b("memoization.memoize",a.M.wb);a.b("memoization.unmemoize",a.M.xc);a.b("memoization.parseMemoText",a.M.lc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.M.yc);a.Y=function(){function b(){if(e)for(var b=
e,c=0,m;g<e;)if(m=d[g++]){if(g>b){if(5E3<=++c){g=e;a.a.$b(Error("'Too much recursion' after processing "+c+" task groups."));break}b=e}try{m()}catch(h){a.a.$b(h)}}}function c(){b();g=e=d.length=0}var d=[],e=0,f=1,g=0;return{scheduler:x.MutationObserver?function(a){var b=u.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):u&&"onreadystatechange"in u.createElement("script")?function(a){var b=u.createElement("script");b.onreadystatechange=
function(){b.onreadystatechange=null;u.documentElement.removeChild(b);b=null;a()};u.documentElement.appendChild(b)}:function(a){setTimeout(a,0)},Wa:function(b){e||a.Y.scheduler(c);d[e++]=b;return f++},cancel:function(a){a-=f-e;a>=g&&a<e&&(d[a]=null)},resetForTesting:function(){var a=e-g;g=e=d.length=0;return a},md:b}}();a.b("tasks",a.Y);a.b("tasks.schedule",a.Y.Wa);a.b("tasks.runEarly",a.Y.md);a.ya={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.B({read:b,write:function(e){clearTimeout(d);
d=a.a.setTimeout(function(){b(e)},c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.cb=!1;f="notifyWhenChangesStop"==e?V:U;a.Ta(function(a){return f(a,d)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.cb||(b.cb=!0,b.Ta(function(c){var e;return function(){a.Y.cancel(e);e=a.Y.Wa(c);b.notifySubscribers(n,"dirty")}}))},notify:function(a,c){a.equalityComparer=
"always"==c?null:J}};var T={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.ya);a.vc=function(b,c,d){this.ia=b;this.gb=c;this.Kc=d;this.R=!1;a.G(this,"dispose",this.k)};a.vc.prototype.k=function(){this.R=!0;this.Kc()};a.J=function(){a.a.Ya(this,D);D.rb(this)};var I="change",D={rb:function(a){a.K={};a.Nb=1},X:function(b,c,d){var e=this;d=d||I;var f=new a.vc(e,c?b.bind(c):b,function(){a.a.La(e.K[d],f);e.Ia&&e.Ia(d)});e.sa&&e.sa(d);e.K[d]||(e.K[d]=[]);e.K[d].push(f);return f},notifySubscribers:function(b,
c){c=c||I;c===I&&this.zc();if(this.Pa(c))try{a.l.Ub();for(var d=this.K[c].slice(0),e=0,f;f=d[e];++e)f.R||f.gb(b)}finally{a.l.end()}},Na:function(){return this.Nb},Uc:function(a){return this.Na()!==a},zc:function(){++this.Nb},Ta:function(b){var c=this,d=a.H(c),e,f,g;c.Ha||(c.Ha=c.notifySubscribers,c.notifySubscribers=W);var k=b(function(){c.Mb=!1;d&&g===c&&(g=c());e=!1;c.tb(f,g)&&c.Ha(f=g)});c.Lb=function(a){c.Mb=e=!0;g=a;k()};c.Kb=function(a){e||(f=a,c.Ha(a,"beforeChange"))}},Pa:function(a){return this.K[a]&&
this.K[a].length},Sc:function(b){if(b)return this.K[b]&&this.K[b].length||0;var c=0;a.a.D(this.K,function(a,b){"dirty"!==a&&(c+=b.length)});return c},tb:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},extend:function(b){var c=this;b&&a.a.D(b,function(b,e){var f=a.ya[b];"function"==typeof f&&(c=f(c,e)||c)});return c}};a.G(D,"subscribe",D.X);a.G(D,"extend",D.extend);a.G(D,"getSubscriptionsCount",D.Sc);a.a.ka&&a.a.Xa(D,Function.prototype);a.J.fn=D;a.hc=function(a){return null!=
a&&"function"==typeof a.X&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.J);a.b("isSubscribable",a.hc);a.va=a.l=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{Ub:b,end:c,oc:function(b){if(e){if(!a.hc(b))throw Error("Only subscribable things can act as dependencies");e.gb.call(e.Gc,b,b.Cc||(b.Cc=++f))}},w:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},Aa:function(){if(e)return e.m.Aa()},Sa:function(){if(e)return e.Sa}}}();a.b("computedContext",
a.va);a.b("computedContext.getDependenciesCount",a.va.Aa);a.b("computedContext.isInitial",a.va.Sa);a.b("ignoreDependencies",a.qd=a.l.w);var E=a.a.Yb("_latestValue");a.N=function(b){function c(){if(0<arguments.length)return c.tb(c[E],arguments[0])&&(c.ga(),c[E]=arguments[0],c.fa()),this;a.l.oc(c);return c[E]}c[E]=b;a.a.ka||a.a.extend(c,a.J.fn);a.J.fn.rb(c);a.a.Ya(c,B);a.options.deferUpdates&&a.ya.deferred(c,!0);return c};var B={equalityComparer:J,t:function(){return this[E]},fa:function(){this.notifySubscribers(this[E])},
ga:function(){this.notifySubscribers(this[E],"beforeChange")}};a.a.ka&&a.a.Xa(B,a.J.fn);var H=a.N.gd="__ko_proto__";B[H]=a.N;a.Oa=function(b,c){return null===b||b===n||b[H]===n?!1:b[H]===c?!0:a.Oa(b[H],c)};a.H=function(b){return a.Oa(b,a.N)};a.Ba=function(b){return"function"==typeof b&&b[H]===a.N||"function"==typeof b&&b[H]===a.B&&b.Vc?!0:!1};a.b("observable",a.N);a.b("isObservable",a.H);a.b("isWriteableObservable",a.Ba);a.b("isWritableObservable",a.Ba);a.b("observable.fn",B);a.G(B,"peek",B.t);a.G(B,
"valueHasMutated",B.fa);a.G(B,"valueWillMutate",B.ga);a.la=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.N(b);a.a.Ya(b,a.la.fn);return b.extend({trackArrayChanges:!0})};a.la.fn={remove:function(b){for(var c=this.t(),d=[],e="function"!=typeof b||a.H(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];e(g)&&(0===d.length&&this.ga(),d.push(g),c.splice(f,1),f--)}d.length&&
this.fa();return d},removeAll:function(b){if(b===n){var c=this.t(),d=c.slice(0);this.ga();c.splice(0,c.length);this.fa();return d}return b?this.remove(function(c){return 0<=a.a.o(b,c)}):[]},destroy:function(b){var c=this.t(),d="function"!=typeof b||a.H(b)?function(a){return a===b}:b;this.ga();for(var e=c.length-1;0<=e;e--)d(c[e])&&(c[e]._destroy=!0);this.fa()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.o(b,c)}):[]},indexOf:function(b){var c=
this();return a.a.o(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ga(),this.t()[d]=c,this.fa())}};a.a.ka&&a.a.Xa(a.la.fn,a.N.fn);a.a.q("pop push reverse shift sort splice unshift".split(" "),function(b){a.la.fn[b]=function(){var a=this.t();this.ga();this.Vb(a,b,arguments);var d=a[b].apply(a,arguments);this.fa();return d===a?this:d}});a.a.q(["slice"],function(b){a.la.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.b("observableArray",a.la);a.ya.trackArrayChanges=function(b,
c){function d(){if(!e){e=!0;var c=b.notifySubscribers;b.notifySubscribers=function(a,b){b&&b!==I||++k;return c.apply(this,arguments)};var d=[].concat(b.t()||[]);f=null;g=b.X(function(c){c=[].concat(c||[]);if(b.Pa("arrayChange")){var e;if(!f||1<k)f=a.a.ib(d,c,b.hb);e=f}d=c;f=null;k=0;e&&e.length&&b.notifySubscribers(e,"arrayChange")})}}b.hb={};c&&"object"==typeof c&&a.a.extend(b.hb,c);b.hb.sparse=!0;if(!b.Vb){var e=!1,f=null,g,k=0,l=b.sa,m=b.Ia;b.sa=function(a){l&&l.call(b,a);"arrayChange"===a&&d()};
b.Ia=function(a){m&&m.call(b,a);"arrayChange"!==a||b.Pa("arrayChange")||(g.k(),e=!1)};b.Vb=function(b,c,d){function m(a,b,c){return l[l.length]={status:a,value:b,index:c}}if(e&&!k){var l=[],g=b.length,t=d.length,G=0;switch(c){case "push":G=g;case "unshift":for(c=0;c<t;c++)m("added",d[c],G+c);break;case "pop":G=g-1;case "shift":g&&m("deleted",b[G],G);break;case "splice":c=Math.min(Math.max(0,0>d[0]?g+d[0]:d[0]),g);for(var g=1===t?g:Math.min(c+(d[1]||0),g),t=c+t-2,G=Math.max(g,t),P=[],n=[],Q=2;c<G;++c,
++Q)c<g&&n.push(m("deleted",b[c],c)),c<t&&P.push(m("added",d[Q],c));a.a.dc(n,P);break;default:return}f=l}}}};var s=a.a.Yb("_state");a.m=a.B=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.pb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}a.l.oc(e);(g.S||g.s&&e.Qa())&&e.aa();return g.T}"object"===typeof b?d=b:(d=d||{},b&&(d.read=
b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={T:n,S:!0,Ra:!1,Fb:!1,R:!1,Va:!1,s:!1,jd:d.read,pb:c||d.owner,i:d.disposeWhenNodeIsRemoved||d.i||null,wa:d.disposeWhen||d.wa,mb:null,r:{},L:0,bc:null};e[s]=g;e.Vc="function"===typeof f;a.a.ka||a.a.extend(e,a.J.fn);a.J.fn.rb(e);a.a.Ya(e,z);d.pure?(g.Va=!0,g.s=!0,a.a.extend(e,$)):d.deferEvaluation&&a.a.extend(e,aa);a.options.deferUpdates&&a.ya.deferred(e,!0);g.i&&(g.Fb=!0,g.i.nodeType||
(g.i=null));g.s||d.deferEvaluation||e.aa();g.i&&e.ba()&&a.a.F.oa(g.i,g.mb=function(){e.k()});return e};var z={equalityComparer:J,Aa:function(){return this[s].L},Pb:function(a,c,d){if(this[s].Va&&c===this)throw Error("A 'pure' computed must not be called recursively");this[s].r[a]=d;d.Ga=this[s].L++;d.na=c.Na()},Qa:function(){var a,c,d=this[s].r;for(a in d)if(d.hasOwnProperty(a)&&(c=d[a],c.ia.Uc(c.na)))return!0},bd:function(){this.Fa&&!this[s].Ra&&this.Fa()},ba:function(){return this[s].S||0<this[s].L},
ld:function(){this.Mb||this.ac()},uc:function(a){if(a.cb&&!this[s].i){var c=a.X(this.bd,this,"dirty"),d=a.X(this.ld,this);return{ia:a,k:function(){c.k();d.k()}}}return a.X(this.ac,this)},ac:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[s].bc),this[s].bc=a.a.setTimeout(function(){b.aa(!0)},c)):b.Fa?b.Fa():b.aa(!0)},aa:function(b){var c=this[s],d=c.wa;if(!c.Ra&&!c.R){if(c.i&&!a.a.nb(c.i)||d&&d()){if(!c.Fb){this.k();return}}else c.Fb=!1;c.Ra=!0;try{this.Qc(b)}finally{c.Ra=!1}c.L||
this.k()}},Qc:function(b){var c=this[s],d=c.Va?n:!c.L,e={Hc:this,Ma:c.r,lb:c.L};a.l.Ub({Gc:e,gb:Y,m:this,Sa:d});c.r={};c.L=0;e=this.Pc(c,e);this.tb(c.T,e)&&(c.s||this.notifySubscribers(c.T,"beforeChange"),c.T=e,c.s?this.zc():b&&this.notifySubscribers(c.T));d&&this.notifySubscribers(c.T,"awake")},Pc:function(b,c){try{var d=b.jd;return b.pb?d.call(b.pb):d()}finally{a.l.end(),c.lb&&!b.s&&a.a.D(c.Ma,X),b.S=!1}},t:function(){var a=this[s];(a.S&&!a.L||a.s&&this.Qa())&&this.aa();return a.T},Ta:function(b){a.J.fn.Ta.call(this,
b);this.Fa=function(){this.Kb(this[s].T);this[s].S=!0;this.Lb(this)}},k:function(){var b=this[s];!b.s&&b.r&&a.a.D(b.r,function(a,b){b.k&&b.k()});b.i&&b.mb&&a.a.F.pc(b.i,b.mb);b.r=null;b.L=0;b.R=!0;b.S=!1;b.s=!1;b.i=null}},$={sa:function(b){var c=this,d=c[s];if(!d.R&&d.s&&"change"==b){d.s=!1;if(d.S||c.Qa())d.r=null,d.L=0,d.S=!0,c.aa();else{var e=[];a.a.D(d.r,function(a,b){e[b.Ga]=a});a.a.q(e,function(a,b){var e=d.r[a],l=c.uc(e.ia);l.Ga=b;l.na=e.na;d.r[a]=l})}d.R||c.notifySubscribers(d.T,"awake")}},
Ia:function(b){var c=this[s];c.R||"change"!=b||this.Pa("change")||(a.a.D(c.r,function(a,b){b.k&&(c.r[a]={ia:b.ia,Ga:b.Ga,na:b.na},b.k())}),c.s=!0,this.notifySubscribers(n,"asleep"))},Na:function(){var b=this[s];b.s&&(b.S||this.Qa())&&this.aa();return a.J.fn.Na.call(this)}},aa={sa:function(a){"change"!=a&&"beforeChange"!=a||this.t()}};a.a.ka&&a.a.Xa(z,a.J.fn);var R=a.N.gd;a.m[R]=a.N;z[R]=a.m;a.Xc=function(b){return a.Oa(b,a.m)};a.Yc=function(b){return a.Oa(b,a.m)&&b[s]&&b[s].Va};a.b("computed",a.m);
a.b("dependentObservable",a.m);a.b("isComputed",a.Xc);a.b("isPureComputed",a.Yc);a.b("computed.fn",z);a.G(z,"peek",z.t);a.G(z,"dispose",z.k);a.G(z,"isActive",z.ba);a.G(z,"getDependenciesCount",z.Aa);a.nc=function(b,c){if("function"===typeof b)return a.m(b,c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.m(b,c)};a.b("pureComputed",a.nc);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof
Number||a instanceof Boolean)return a;var k=a instanceof Array?[]:{};g.save(a,k);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":k[c]=d;break;case "object":case "undefined":var h=g.get(d);k[c]=h!==n?h:b(d,f,g)}});return k}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.Ib=[]}a.wc=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");
return b(c,function(b){for(var c=0;a.H(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.wc(b);return a.a.Eb(b,c,d)};d.prototype={save:function(b,c){var d=a.a.o(this.keys,b);0<=d?this.Ib[d]=c:(this.keys.push(b),this.Ib.push(c))},get:function(b){b=a.a.o(this.keys,b);return 0<=b?this.Ib[b]:n}}})();a.b("toJS",a.wc);a.b("toJSON",a.toJSON);(function(){a.j={u:function(b){switch(a.a.A(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?a.a.e.get(b,a.d.options.xb):7>=a.a.C?b.getAttributeNode("value")&&
b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex]):n;default:return b.value}},ha:function(b,c,d){switch(a.a.A(b)){case "option":switch(typeof c){case "string":a.a.e.set(b,a.d.options.xb,n);"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__;b.value=c;break;default:a.a.e.set(b,a.d.options.xb,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===typeof c?c:""}break;case "select":if(""===c||
null===c)c=n;for(var e=-1,f=0,g=b.options.length,k;f<g;++f)if(k=a.j.u(b.options[f]),k==c||""==k&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e;break;default:if(null===c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.j);a.b("selectExtensions.readValue",a.j.u);a.b("selectExtensions.writeValue",a.j.ha);a.h=function(){function b(b){b=a.a.$a(b);123===b.charCodeAt(0)&&(b=b.slice(1,-1));var c=[],d=b.match(e),r,k=[],p=0;if(d){d.push(",");for(var A=0,y;y=d[A];++A){var t=y.charCodeAt(0);
if(44===t){if(0>=p){c.push(r&&k.length?{key:r,value:k.join("")}:{unknown:r||k.join("")});r=p=0;k=[];continue}}else if(58===t){if(!p&&!r&&1===k.length){r=k.pop();continue}}else 47===t&&A&&1<y.length?(t=d[A-1].match(f))&&!g[t[0]]&&(b=b.substr(b.indexOf(y)+1),d=b.match(e),d.push(","),A=-1,y="/"):40===t||123===t||91===t?++p:41===t||125===t||93===t?--p:r||k.length||34!==t&&39!==t||(y=y.slice(1,-1));k.push(y)}}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,
e=RegExp("\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'|/(?:[^/\\\\]|\\\\.)*/w*|[^\\s:,/][^,\"'{}()/:[\\]]*[^\\s,\"'{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},k={};return{ta:[],ea:k,yb:b,Ua:function(e,m){function h(b,e){var m;if(!A){var l=a.getBindingHandler(b);if(l&&l.preprocess&&!(e=l.preprocess(e,b,h)))return;if(l=k[b])m=e,0<=a.a.o(c,m)?m=!1:(l=m.match(d),m=null===l?!1:l[1]?"Object("+l[1]+")"+l[2]:m),l=m;l&&g.push("'"+b+"':function(_z){"+m+"=_z}")}p&&(e=
"function(){return "+e+" }");f.push("'"+b+"':"+e)}m=m||{};var f=[],g=[],p=m.valueAccessors,A=m.bindingParams,y="string"===typeof e?b(e):e;a.a.q(y,function(a){h(a.key||a.unknown,a.value)});g.length&&h("_ko_property_writers","{"+g.join(",")+" }");return f.join(",")},ad:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},Ea:function(b,c,d,e,f){if(b&&a.H(b))!a.Ba(b)||f&&b.t()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.h);a.b("expressionRewriting.bindingRewriteValidators",
a.h.ta);a.b("expressionRewriting.parseObjectLiteral",a.h.yb);a.b("expressionRewriting.preProcessBindings",a.h.Ua);a.b("expressionRewriting._twoWayBindings",a.h.ea);a.b("jsonExpressionRewriting",a.h);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.h.Ua);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&k.test(f?a.text:a.nodeValue)}function d(a,d){for(var e=a,f=1,l=[];e=e.nextSibling;){if(c(e)&&(f--,0===f))return l;l.push(e);
b(e)&&f++}if(!d)throw Error("Cannot find closing comment tag to match: "+a.nodeValue);return null}function e(a,b){var c=d(a,b);return c?0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=u&&"\x3c!--test--\x3e"===u.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,k=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,l={ul:!0,ol:!0};a.f={Z:{},childNodes:function(a){return b(a)?d(a):a.childNodes},xa:function(c){if(b(c)){c=a.f.childNodes(c);for(var d=
0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.ob(c)},da:function(c,d){if(b(c)){a.f.xa(c);for(var e=c.nextSibling,f=0,l=d.length;f<l;f++)e.parentNode.insertBefore(d[f],e)}else a.a.da(c,d)},mc:function(a,c){b(a)?a.parentNode.insertBefore(c,a.nextSibling):a.firstChild?a.insertBefore(c,a.firstChild):a.appendChild(c)},gc:function(c,d,e){e?b(c)?c.parentNode.insertBefore(d,e.nextSibling):e.nextSibling?c.insertBefore(d,e.nextSibling):c.appendChild(d):a.f.mc(c,d)},firstChild:function(a){return b(a)?!a.nextSibling||
c(a.nextSibling)?null:a.nextSibling:a.firstChild},nextSibling:function(a){b(a)&&(a=e(a));return a.nextSibling&&c(a.nextSibling)?null:a.nextSibling},Tc:b,pd:function(a){return(a=(f?a.text:a.nodeValue).match(g))?a[1]:null},kc:function(d){if(l[a.a.A(d)]){var h=d.firstChild;if(h){do if(1===h.nodeType){var f;f=h.firstChild;var g=null;if(f){do if(g)g.push(f);else if(b(f)){var k=e(f,!0);k?f=k:g=[f]}else c(f)&&(g=[f]);while(f=f.nextSibling)}if(f=g)for(g=h.nextSibling,k=0;k<f.length;k++)g?d.insertBefore(f[k],
g):d.appendChild(f[k])}while(h=h.nextSibling)}}}}})();a.b("virtualElements",a.f);a.b("virtualElements.allowedBindings",a.f.Z);a.b("virtualElements.emptyNode",a.f.xa);a.b("virtualElements.insertAfter",a.f.gc);a.b("virtualElements.prepend",a.f.mc);a.b("virtualElements.setDomNodeChildren",a.f.da);(function(){a.Q=function(){this.Fc={}};a.a.extend(a.Q.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=b.getAttribute("data-bind")||a.g.getComponentNameForNode(b);case 8:return a.f.Tc(b);
default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.g.Ob(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.g.Ob(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.f.pd(b);default:return null}},parseBindingsString:function(b,c,d,e){try{var f=this.Fc,g=b+(e&&e.valueAccessors||
""),k;if(!(k=f[g])){var l,m="with($context){with($data||{}){return{"+a.h.Ua(b,e)+"}}}";l=new Function("$context","$element",m);k=f[g]=l}return k(c,d)}catch(h){throw h.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+h.message,h;}}});a.Q.instance=new a.Q})();a.b("bindingProvider",a.Q);(function(){function b(a){return function(){return a}}function c(a){return a()}function d(b){return a.a.Ca(a.l.w(b),function(a,c){return function(){return b()[c]}})}function e(c,e,h){return"function"===
typeof c?d(c.bind(null,e,h)):a.a.Ca(c,b)}function f(a,b){return d(this.getBindings.bind(this,a,b))}function g(b,c,d){var e,h=a.f.firstChild(c),f=a.Q.instance,m=f.preprocessNode;if(m){for(;e=h;)h=a.f.nextSibling(e),m.call(f,e);h=a.f.firstChild(c)}for(;e=h;)h=a.f.nextSibling(e),k(b,e,d)}function k(b,c,d){var e=!0,h=1===c.nodeType;h&&a.f.kc(c);if(h&&d||a.Q.instance.nodeHasBindings(c))e=m(c,null,b,d).shouldBindDescendants;e&&!r[a.a.A(c)]&&g(b,c,!h)}function l(b){var c=[],d={},e=[];a.a.D(b,function Z(h){if(!d[h]){var f=
a.getBindingHandler(h);f&&(f.after&&(e.push(h),a.a.q(f.after,function(c){if(b[c]){if(-1!==a.a.o(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));Z(c)}}),e.length--),c.push({key:h,fc:f}));d[h]=!0}});return c}function m(b,d,e,h){var m=a.a.e.get(b,q);if(!d){if(m)throw Error("You cannot apply bindings multiple times to the same element.");a.a.e.set(b,q,!0)}!m&&h&&a.tc(b,e);var g;if(d&&"function"!==typeof d)g=d;else{var k=a.Q.instance,r=k.getBindingAccessors||
f,p=a.B(function(){(g=d?d(e,b):r.call(k,b,e))&&e.P&&e.P();return g},null,{i:b});g&&p.ba()||(p=null)}var u;if(g){var v=p?function(a){return function(){return c(p()[a])}}:function(a){return g[a]},s=function(){return a.a.Ca(p?p():g,c)};s.get=function(a){return g[a]&&c(v(a))};s.has=function(a){return a in g};h=l(g);a.a.q(h,function(c){var d=c.fc.init,h=c.fc.update,f=c.key;if(8===b.nodeType&&!a.f.Z[f])throw Error("The binding '"+f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.l.w(function(){var a=
d(b,v(f),s,e.$data,e);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f}}),"function"==typeof h&&a.B(function(){h(b,v(f),s,e.$data,e)},null,{i:b})}catch(m){throw m.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+m.message,m;}})}return{shouldBindDescendants:u===n}}function h(b){return b&&b instanceof a.U?b:new a.U(b)}
a.d={};var r={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.d[b]};a.U=function(b,c,d,e){var h=this,f="function"==typeof b&&!a.H(b),m,g=a.B(function(){var m=f?b():b,l=a.a.c(m);c?(c.P&&c.P(),a.a.extend(h,c),g&&(h.P=g)):(h.$parents=[],h.$root=l,h.ko=a);h.$rawData=m;h.$data=l;d&&(h[d]=l);e&&e(h,c,l);return h.$data},null,{wa:function(){return m&&!a.a.Qb(m)},i:!0});g.ba()&&(h.P=g,g.equalityComparer=null,m=[],g.Ac=function(b){m.push(b);a.a.F.oa(b,function(b){a.a.La(m,b);m.length||
(g.k(),h.P=g=n)})})};a.U.prototype.createChildContext=function(b,c,d){return new a.U(b,this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)})};a.U.prototype.extend=function(b){return new a.U(this.P||this.$data,this,null,function(c,d){c.$rawData=d.$rawData;a.a.extend(c,"function"==typeof b?b():b)})};var q=a.a.e.I(),p=a.a.e.I();a.tc=function(b,c){if(2==arguments.length)a.a.e.set(b,p,c),c.P&&c.P.Ac(b);else return a.a.e.get(b,
p)};a.Ja=function(b,c,d){1===b.nodeType&&a.f.kc(b);return m(b,c,h(d),!0)};a.Dc=function(b,c,d){d=h(d);return a.Ja(b,e(c,d,b),d)};a.eb=function(a,b){1!==b.nodeType&&8!==b.nodeType||g(h(a),b,!0)};a.Rb=function(a,b){!v&&x.jQuery&&(v=x.jQuery);if(b&&1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");b=b||x.document.body;k(h(a),b,!0)};a.kb=function(b){switch(b.nodeType){case 1:case 8:var c=a.tc(b);if(c)return c;
if(b.parentNode)return a.kb(b.parentNode)}return n};a.Jc=function(b){return(b=a.kb(b))?b.$data:n};a.b("bindingHandlers",a.d);a.b("applyBindings",a.Rb);a.b("applyBindingsToDescendants",a.eb);a.b("applyBindingAccessorsToNode",a.Ja);a.b("applyBindingsToNode",a.Dc);a.b("contextFor",a.kb);a.b("dataFor",a.Jc)})();(function(b){function c(c,e){var m=f.hasOwnProperty(c)?f[c]:b,h;m?m.X(e):(m=f[c]=new a.J,m.X(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Zc:e};delete f[c];h||e?m.notifySubscribers(b):
a.Y.Wa(function(){m.notifySubscribers(b)})}),h=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,c)}):b(null,null)})}function e(c,d,f,h){h||(h=a.g.loaders.slice(0));var g=h.shift();if(g){var q=g[c];if(q){var p=!1;if(q.apply(g,d.concat(function(a){p?f(null):null!==a?f(a):e(c,d,f,h)}))!==b&&(p=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,h)}else f(null)}
var f={},g={};a.g={get:function(d,e){var f=g.hasOwnProperty(d)?g[d]:b;f?f.Zc?a.l.w(function(){e(f.definition)}):a.Y.Wa(function(){e(f.definition)}):c(d,e)},Xb:function(a){delete g[a]},Jb:e};a.g.loaders=[];a.b("components",a.g);a.b("components.get",a.g.get);a.b("components.clearCachedDefinition",a.g.Xb)})();(function(){function b(b,c,d,e){function g(){0===--y&&e(k)}var k={},y=2,t=d.template;d=d.viewModel;t?f(c,t,function(c){a.g.Jb("loadTemplate",[b,c],function(a){k.template=a;g()})}):g();d?f(c,d,function(c){a.g.Jb("loadViewModel",
[b,c],function(a){k[l]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});else if("function"===typeof b[l])d(b[l]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.A(b)){case "script":return a.a.ma(b.text);case "textarea":return a.a.ma(b.value);case "template":if(e(b.content))return a.a.ua(b.content.childNodes)}return a.a.ua(b.childNodes)}function e(a){return x.DocumentFragment?
a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?O||x.require?(O||x.require)([b.require],c):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var k={};a.g.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.g.ub(b))throw Error("Component "+b+" is already registered");k[b]=c};a.g.ub=function(a){return k.hasOwnProperty(a)};a.g.od=function(b){delete k[b];
a.g.Xb(b)};a.g.Zb={getConfig:function(a,b){b(k.hasOwnProperty(a)?k[a]:null)},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ma(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.V(c.childNodes));else if(c.element)if(c=c.element,x.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var l=u.getElementById(c);l?f(d(l)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+
c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),b,d)}};var l="createViewModel";a.b("components.register",a.g.register);a.b("components.isRegistered",a.g.ub);a.b("components.unregister",a.g.od);a.b("components.defaultLoader",a.g.Zb);a.g.loaders.push(a.g.Zb);a.g.Bc=k})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ca(f,function(c){return a.m(c,null,{i:b})}),g=a.a.Ca(f,function(c){var e=
c.t();return c.ba()?a.m({read:function(){return a.a.c(c())},write:a.Ba(e)&&function(a){c()(a)},i:b}):e});g.hasOwnProperty("$raw")||(g.$raw=f);return g}return{$raw:{}}}a.g.getComponentNameForNode=function(b){var c=a.a.A(b);if(a.g.ub(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.C&&b.tagName===c))return c};a.g.Ob=function(c,e,f,g){if(1===e.nodeType){var k=a.g.getComponentNameForNode(e);if(k){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
var l={name:k,params:b(e,f)};c.component=g?function(){return l}:l}}return c};var c=new a.Q;9>a.a.C&&(a.g.register=function(a){return function(b){u.createElement(b);return a.apply(this,arguments)}}(a.g.register),u.createDocumentFragment=function(b){return function(){var c=b(),f=a.g.Bc,g;for(g in f)f.hasOwnProperty(g)&&c.createElement(g);return c}}(u.createDocumentFragment))})();(function(b){function c(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.ua(c);a.f.da(d,b)}
function d(a,b,c,d){var e=a.createViewModel;return e?e.call(a,d,{element:b,templateNodes:c}):d}var e=0;a.d.component={init:function(f,g,k,l,m){function h(){var a=r&&r.dispose;"function"===typeof a&&a.call(r);q=r=null}var r,q,p=a.a.V(a.f.childNodes(f));a.a.F.oa(f,h);a.m(function(){var l=a.a.c(g()),k,t;"string"===typeof l?k=l:(k=a.a.c(l.name),t=a.a.c(l.params));if(!k)throw Error("No component name specified");var n=q=++e;a.g.get(k,function(e){if(q===n){h();if(!e)throw Error("Unknown component '"+k+
"'");c(k,e,f);var g=d(e,f,p,t);e=m.createChildContext(g,b,function(a){a.$component=g;a.$componentTemplateNodes=p});r=g;a.eb(e,f)}})},null,{i:f});return{controlsDescendantBindings:!0}}};a.f.Z.component=!0})();var S={"class":"className","for":"htmlFor"};a.d.attr={update:function(b,c){var d=a.a.c(c())||{};a.a.D(d,function(c,d){d=a.a.c(d);var g=!1===d||null===d||d===n;g&&b.removeAttribute(c);8>=a.a.C&&c in S?(c=S[c],g?b.removeAttribute(c):b[c]=d):g||b.setAttribute(c,d.toString());"name"===c&&a.a.rc(b,
g?"":d.toString())})}};(function(){a.d.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=p?g():e;if(!a.va.Sa()&&(!l||e)){var m=a.l.w(c);if(h){var k=r?m.t():m;q!==f?(e&&(a.a.pa(k,f,!0),a.a.pa(k,q,!1)),q=f):a.a.pa(k,f,e);r&&a.Ba(m)&&m(k)}else a.h.Ea(m,d,"checked",f,!0)}}function f(){var d=a.a.c(c());b.checked=h?0<=a.a.o(d,g()):k?d:g()===d}var g=a.nc(function(){return d.has("checkedValue")?a.a.c(d.get("checkedValue")):d.has("value")?a.a.c(d.get("value")):b.value}),k=
"checkbox"==b.type,l="radio"==b.type;if(k||l){var m=c(),h=k&&a.a.c(m)instanceof Array,r=!(h&&m.push&&m.splice),q=h?g():n,p=l||h;l&&!b.name&&a.d.uniqueName.init(b,function(){return!0});a.m(e,null,{i:b});a.a.p(b,"click",e);a.m(f,null,{i:b});m=n}}};a.h.ea.checked=!0;a.d.checkedValue={update:function(b,c){b.value=a.a.c(c())}}})();a.d.css={update:function(b,c){var d=a.a.c(c());null!==d&&"object"==typeof d?a.a.D(d,function(c,d){d=a.a.c(d);a.a.bb(b,c,d)}):(d=a.a.$a(String(d||"")),a.a.bb(b,b.__ko__cssValue,
!1),b.__ko__cssValue=d,a.a.bb(b,d,!0))}};a.d.enable={update:function(b,c){var d=a.a.c(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.d.disable={update:function(b,c){a.d.enable.update(b,function(){return!a.a.c(c())})}};a.d.event={init:function(b,c,d,e,f){var g=c()||{};a.a.D(g,function(g){"string"==typeof g&&a.a.p(b,g,function(b){var m,h=c()[g];if(h){try{var r=a.a.V(arguments);e=f.$data;r.unshift(e);m=h.apply(e,r)}finally{!0!==m&&(b.preventDefault?b.preventDefault():
b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.d.foreach={ic:function(b){return function(){var c=b(),d=a.a.zb(c);if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.W.sb};a.a.c(c);return{foreach:d.data,as:d.as,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.W.sb}}},init:function(b,c){return a.d.template.init(b,
a.d.foreach.ic(c))},update:function(b,c,d,e,f){return a.d.template.update(b,a.d.foreach.ic(c),d,e,f)}};a.h.ta.foreach=!1;a.f.Z.foreach=!0;a.d.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(h){g=f.body}e=g===b}f=c();a.h.Ea(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.p(b,"focus",f);a.a.p(b,"focusin",f);a.a.p(b,"blur",g);a.a.p(b,
"focusout",g)},update:function(b,c){var d=!!a.a.c(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.l.w(a.a.Da,null,[b,d?"focusin":"focusout"]))}};a.h.ea.hasfocus=!0;a.d.hasFocus=a.d.hasfocus;a.h.ea.hasFocus=!0;a.d.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Cb(b,c())}};K("if");K("ifnot",!1,!0);K("with",!0,!1,function(a,c){return a.createChildContext(c)});var L={};
a.d.options={init:function(b){if("select"!==a.a.A(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.Ka(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,e){if(A&&h)a.j.ha(b,a.a.c(d.get("value")),!0);else if(p.length){var f=0<=a.a.o(p,a.j.u(e[0]));a.a.sc(e[0],f);A&&!f&&a.l.w(a.a.Da,null,[b,
"change"])}}var k=b.multiple,l=0!=b.length&&k?b.scrollTop:null,m=a.a.c(c()),h=d.get("valueAllowUnset")&&d.has("value"),r=d.get("optionsIncludeDestroyed");c={};var q,p=[];h||(k?p=a.a.fb(e(),a.j.u):0<=b.selectedIndex&&p.push(a.j.u(b.options[b.selectedIndex])));m&&("undefined"==typeof m.length&&(m=[m]),q=a.a.Ka(m,function(b){return r||b===n||null===b||!a.a.c(b._destroy)}),d.has("optionsCaption")&&(m=a.a.c(d.get("optionsCaption")),null!==m&&m!==n&&q.unshift(L)));var A=!1;c.beforeRemove=function(a){b.removeChild(a)};
m=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(m=function(b,c){g(0,c);a.l.w(d.get("optionsAfterRender"),null,[c[0],b!==L?b:n])});a.a.Bb(b,q,function(c,e,g){g.length&&(p=!h&&g[0].selected?[a.j.u(g[0])]:[],A=!0);e=b.ownerDocument.createElement("option");c===L?(a.a.Za(e,d.get("optionsCaption")),a.j.ha(e,n)):(g=f(c,d.get("optionsValue"),c),a.j.ha(e,a.a.c(g)),c=f(c,d.get("optionsText"),g),a.a.Za(e,c));return[e]},c,m);a.l.w(function(){h?a.j.ha(b,a.a.c(d.get("value")),
!0):(k?p.length&&e().length<p.length:p.length&&0<=b.selectedIndex?a.j.u(b.options[b.selectedIndex])!==p[0]:p.length||0<=b.selectedIndex)&&a.a.Da(b,"change")});a.a.Nc(b);l&&20<Math.abs(l-b.scrollTop)&&(b.scrollTop=l)}};a.d.options.xb=a.a.e.I();a.d.selectedOptions={after:["options","foreach"],init:function(b,c,d){a.a.p(b,"change",function(){var e=c(),f=[];a.a.q(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.j.u(b))});a.h.Ea(e,d,"selectedOptions",f)})},update:function(b,c){if("select"!=
a.a.A(b))throw Error("values binding applies only to SELECT elements");var d=a.a.c(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.q(b.getElementsByTagName("option"),function(b){var c=0<=a.a.o(d,a.j.u(b));b.selected!=c&&a.a.sc(b,c)});b.scrollTop=e}};a.h.ea.selectedOptions=!0;a.d.style={update:function(b,c){var d=a.a.c(c()||{});a.a.D(d,function(c,d){d=a.a.c(d);if(null===d||d===n||!1===d)d="";b.style[c]=d})}};a.d.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");
a.a.p(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b)}finally{!0!==d&&(a.preventDefault?a.preventDefault():a.returnValue=!1)}})}};a.d.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Za(b,c())}};a.f.Z.text=!0;(function(){if(x&&x.navigator)var b=function(a){if(a)return parseFloat(a[1])},c=x.opera&&x.opera.version&&parseInt(x.opera.version()),d=x.navigator.userAgent,e=b(d.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),f=b(d.match(/Firefox\/([^ ]*)/));
if(10>a.a.C)var g=a.a.e.I(),k=a.a.e.I(),l=function(b){var c=this.activeElement;(c=c&&a.a.e.get(c,k))&&c(b)},m=function(b,c){var d=b.ownerDocument;a.a.e.get(d,g)||(a.a.e.set(d,g,!0),a.a.p(d,"selectionchange",l));a.a.e.set(b,k,c)};a.d.textInput={init:function(b,d,g){function l(c,d){a.a.p(b,c,d)}function k(){var c=a.a.c(d());if(null===c||c===n)c="";v!==n&&c===v?a.a.setTimeout(k,4):b.value!==c&&(u=c,b.value=c)}function y(){s||(v=b.value,s=a.a.setTimeout(t,4))}function t(){clearTimeout(s);v=s=n;var c=
b.value;u!==c&&(u=c,a.h.Ea(d(),g,"textInput",c))}var u=b.value,s,v,x=9==a.a.C?y:t;10>a.a.C?(l("propertychange",function(a){"value"===a.propertyName&&x(a)}),8==a.a.C&&(l("keyup",t),l("keydown",t)),8<=a.a.C&&(m(b,x),l("dragend",y))):(l("input",t),5>e&&"textarea"===a.a.A(b)?(l("keydown",y),l("paste",y),l("cut",y)):11>c?l("keydown",y):4>f&&(l("DOMAutoComplete",t),l("dragdrop",t),l("drop",t)));l("change",t);a.m(k,null,{i:b})}};a.h.ea.textInput=!0;a.d.textinput={preprocess:function(a,b,c){c("textInput",
a)}}})();a.d.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.d.uniqueName.Ic;a.a.rc(b,d)}}};a.d.uniqueName.Ic=0;a.d.value={after:["options","foreach"],init:function(b,c,d){if("input"!=b.tagName.toLowerCase()||"checkbox"!=b.type&&"radio"!=b.type){var e=["change"],f=d.get("valueUpdate"),g=!1,k=null;f&&("string"==typeof f&&(f=[f]),a.a.ra(e,f),e=a.a.Tb(e));var l=function(){k=null;g=!1;var e=c(),f=a.j.u(b);a.h.Ea(e,d,"value",f)};!a.a.C||"input"!=b.tagName.toLowerCase()||"text"!=b.type||
"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.o(e,"propertychange")||(a.a.p(b,"propertychange",function(){g=!0}),a.a.p(b,"focus",function(){g=!1}),a.a.p(b,"blur",function(){g&&l()}));a.a.q(e,function(c){var d=l;a.a.nd(c,"after")&&(d=function(){k=a.j.u(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.p(b,c,d)});var m=function(){var e=a.a.c(c()),f=a.j.u(b);if(null!==k&&e===k)a.a.setTimeout(m,0);else if(e!==f)if("select"===a.a.A(b)){var g=d.get("valueAllowUnset"),f=function(){a.j.ha(b,
e,g)};f();g||e===a.j.u(b)?a.a.setTimeout(f,0):a.l.w(a.a.Da,null,[b,"change"])}else a.j.ha(b,e)};a.m(m,null,{i:b})}else a.Ja(b,{checkedValue:c})},update:function(){}};a.h.ea.value=!0;a.d.visible={update:function(b,c){var d=a.a.c(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};(function(b){a.d[b]={init:function(c,d,e,f,g){return a.d.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");a.O=function(){};a.O.prototype.renderTemplateSource=
function(){throw Error("Override renderTemplateSource");};a.O.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.O.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||u;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.v.n(d)}if(1==b.nodeType||8==b.nodeType)return new a.v.qa(b);throw Error("Unknown template type: "+b);};a.O.prototype.renderTemplate=function(a,c,d,e){a=this.makeTemplateSource(a,
e);return this.renderTemplateSource(a,c,d,e)};a.O.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.O.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.O);a.Gb=function(){function b(b,c,d,k){b=a.h.yb(b);for(var l=a.h.ta,m=0;m<b.length;m++){var h=b[m].key;if(l.hasOwnProperty(h)){var r=l[h];if("function"===typeof r){if(h=
r(b[m].value))throw Error(h);}else if(!r)throw Error("This template engine does not support the '"+h+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.h.Ua(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return k.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{Oc:function(b,
c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.Gb.dd(b,c)},d)},dd:function(a,f){return a.replace(c,function(a,c,d,e,h){return b(h,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},Ec:function(b,c){return a.M.wb(function(d,k){var l=d.nextSibling;l&&l.nodeName.toLowerCase()===c&&a.Ja(l,b,k)})}}}();a.b("__tr_ambtns",a.Gb.Ec);(function(){a.v={};a.v.n=function(b){if(this.n=b){var c=a.a.A(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&
b.content&&11===b.content.nodeType?3:4}};a.v.n.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.n[b];var c=arguments[0];"innerHTML"===b?a.a.Cb(this.n,c):this.n[b]=c};var b=a.a.e.I()+"_";a.v.n.prototype.data=function(c){if(1===arguments.length)return a.a.e.get(this.n,b+c);a.a.e.set(this.n,b+c,arguments[1])};var c=a.a.e.I();a.v.n.prototype.nodes=function(){var b=this.n;if(0==arguments.length)return(a.a.e.get(b,c)||{}).jb||(3===this.ab?
b.content:4===this.ab?b:n);a.a.e.set(b,c,{jb:arguments[0]})};a.v.qa=function(a){this.n=a};a.v.qa.prototype=new a.v.n;a.v.qa.prototype.text=function(){if(0==arguments.length){var b=a.a.e.get(this.n,c)||{};b.Hb===n&&b.jb&&(b.Hb=b.jb.innerHTML);return b.Hb}a.a.e.set(this.n,c,{Hb:arguments[0]})};a.b("templateSources",a.v);a.b("templateSources.domElement",a.v.n);a.b("templateSources.anonymousTemplate",a.v.qa)})();(function(){function b(b,c,d){var e;for(c=a.f.nextSibling(c);b&&(e=b)!==c;)b=a.f.nextSibling(e),
d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,k=a.Q.instance,n=k.preprocessNode;if(n){b(e,f,function(a,b){var c=a.previousSibling,d=n.call(k,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):(c.push(e,f),a.a.za(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.Rb(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.M.yc(b,[d])});a.a.za(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,
e,f,k,q){q=q||{};var p=(b&&d(b)||f||{}).ownerDocument,n=q.templateEngine||g;a.Gb.Oc(f,n,p);f=n.renderTemplate(f,k,q,p);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");p=!1;switch(e){case "replaceChildren":a.f.da(b,f);p=!0;break;case "replaceNode":a.a.qc(b,f);p=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}p&&(c(f,k),q.afterRender&&a.l.w(q.afterRender,null,[f,k.$data]));
return f}function f(b,c,d){return a.H(b)?b():"function"===typeof b?b(c,d):b}var g;a.Db=function(b){if(b!=n&&!(b instanceof a.O))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.Ab=function(b,c,h,k,q){h=h||{};if((h.templateEngine||g)==n)throw Error("Set a template engine before calling renderTemplate");q=q||"replaceChildren";if(k){var p=d(k);return a.B(function(){var g=c&&c instanceof a.U?c:new a.U(a.a.c(c)),n=f(b,g.$data,g),g=e(k,q,n,g,h);"replaceNode"==q&&(k=g,p=d(k))},null,
{wa:function(){return!p||!a.a.nb(p)},i:p&&"replaceNode"==q?p.parentNode:p})}return a.M.wb(function(d){a.Ab(b,c,h,d,"replaceNode")})};a.kd=function(b,d,g,k,q){function p(a,b){c(b,s);g.afterRender&&g.afterRender(b,a);s=null}function u(a,c){s=q.createChildContext(a,g.as,function(a){a.$index=c});var d=f(b,a,s);return e(null,"ignoreTargetNode",d,s,g)}var s;return a.B(function(){var b=a.a.c(d)||[];"undefined"==typeof b.length&&(b=[b]);b=a.a.Ka(b,function(b){return g.includeDestroyed||b===n||null===b||!a.a.c(b._destroy)});
a.l.w(a.a.Bb,null,[k,b,u,g,p])},null,{i:k})};var k=a.a.e.I();a.d.template={init:function(b,c){var d=a.a.c(c());if("string"==typeof d||d.name)a.f.xa(b);else{if("nodes"in d){if(d=d.nodes||[],a.H(d))throw Error('The "nodes" option must be a plain, non-observable array.');}else d=a.f.childNodes(b);d=a.a.jc(d);(new a.v.qa(b)).nodes(d)}return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c(),s;c=a.a.c(g);d=!0;e=null;"string"==typeof c?c={}:(g=c.name,"if"in c&&(d=a.a.c(c["if"])),d&&"ifnot"in
c&&(d=!a.a.c(c.ifnot)),s=a.a.c(c.data));"foreach"in c?e=a.kd(g||b,d&&c.foreach||[],c,b,f):d?(f="data"in c?f.createChildContext(s,c.as):f,e=a.Ab(g||b,f,c,b)):a.f.xa(b);f=e;(s=a.a.e.get(b,k))&&"function"==typeof s.k&&s.k();a.a.e.set(b,k,f&&f.ba()?f:n)}};a.h.ta.template=function(b){b=a.h.yb(b);return 1==b.length&&b[0].unknown||a.h.ad(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.f.Z.template=!0})();a.b("setTemplateEngine",a.Db);a.b("renderTemplate",
a.Ab);a.a.dc=function(a,c,d){if(a.length&&c.length){var e,f,g,k,l;for(e=f=0;(!d||e<d)&&(k=a[f]);++f){for(g=0;l=c[g];++g)if(k.value===l.value){k.moved=l.multiChannelNew;l.moved=k.multiChannelNew;c.splice(g,1);e=g=0;break}e+=g}}};a.a.ib=function(){function b(b, d, e, f, g){var k=Math.min,l=Math.max,m=[],h,n=b.length,q,p=d.length,s=p-n||1,u=n+p+1,t,v,x;for(h=0; h<=n; h++)for(v=t,m.push(t=[]),x=k(p,h+s),q=l(0,h-1); q<=x; q++)t[q]=q?h?b[h-1]===d[q-1]?v[q-1]:k(v[q]||u,t[q-1]||u)+1:q+1:h+1;k=[];l=[];s=[];h=n;for(q=p; h||q;)p=m[h][q]-
1,q&&p===m[h][q-1]?l.push(k[k.length]={status:e,value:d[--q],index:q}):h&&p===m[h-1][q]?s.push(k[k.length]={status:f,value:b[--h],index:h}):(--q,--h,g.sparse||k.push({status:"retained",value:d[q]}));a.a.dc(s,l,!g.dontLimitMoves&&10*n);return k.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.ib);(function(){function b(b,c,d,k,l){var m=[],
h=a.B(function(){var h=c(d,l,a.a.za(m,b))||[];0<m.length&&(a.a.qc(m,h),k&&a.l.w(k,null,[d,h,l]));m.length=0;a.a.ra(m,h)},null,{i:b,wa:function(){return!a.a.Qb(m)}});return{ca:m,B:h.ba()?h:n}}var c=a.a.e.I(),d=a.a.e.I();a.a.Bb=function(e,f,g,k,l){function m(b,c){w=q[c];v!==c&&(D[b]=w);w.qb(v++);a.a.za(w.ca,e);u.push(w);z.push(w)}function h(b,c){if(b)for(var d=0,e=c.length;d<e;d++)c[d]&&a.a.q(c[d].ca,function(a){b(a,d,c[d].ja)})}f=f||[];k=k||{};var r=a.a.e.get(e,c)===n,q=a.a.e.get(e,c)||[],p=a.a.fb(q,
function(a){return a.ja}),s=a.a.ib(p,f,k.dontLimitMoves),u=[],t=0,v=0,x=[],z=[];f=[];for(var D=[],p=[],w,C=0,B,E;B=s[C];C++)switch(E=B.moved,B.status){case "deleted":E===n&&(w=q[t],w.B&&(w.B.k(),w.B=n),a.a.za(w.ca,e).length&&(k.beforeRemove&&(u.push(w),z.push(w),w.ja===d?w=null:f[C]=w),w&&x.push.apply(x,w.ca)));t++;break;case "retained":m(C,t++);break;case "added":E!==n?m(C,E):(w={ja:B.value,qb:a.N(v++)},u.push(w),z.push(w),r||(p[C]=w))}a.a.e.set(e,c,u);h(k.beforeMove,D);a.a.q(x,k.beforeRemove?a.$:
a.removeNode);for(var C=0,r=a.f.firstChild(e),F;w=z[C];C++){w.ca||a.a.extend(w,b(e,g,w.ja,l,w.qb));for(t=0;s=w.ca[t];r=s.nextSibling,F=s,t++)s!==r&&a.f.gc(e,s,F);!w.Wc&&l&&(l(w.ja,w.ca,w.qb),w.Wc=!0)}h(k.beforeRemove,f);for(C=0;C<f.length;++C)f[C]&&(f[C].ja=d);h(k.afterMove,D);h(k.afterAdd,p)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.Bb);a.W=function(){this.allowTemplateRewriting=!1};a.W.prototype=new a.O;a.W.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.C?0:b.nodes)?
b.nodes():null)return a.a.V(c.cloneNode(!0).childNodes);b=b.text();return a.a.ma(b,e)};a.W.sb=new a.W;a.Db(a.W.sb);a.b("nativeTemplateEngine",a.W);(function(){a.vb=function(){var a=this.$c=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();this.renderTemplateSource=function(b,e,f,g){g=g||u;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var k=b.data("precompiled");
k||(k=b.text()||"",k=v.template(null,"{{ko_with $item.koBindingContext}}"+k+"{{/ko_with}}"),b.data("precompiled",k));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(k,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+a+" })()) }}"};this.addTemplate=function(a,b){u.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || '');"},
v.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.vb.prototype=new a.O;var b=new a.vb;0<b.$c&&a.Db(b);a.b("jqueryTmplTemplateEngine",a.vb)})()})})();})();

/**
 * Created by fei on 2015/12/4.
 */
define('wa_Tip',["jquery"],function($) {
    "use strict";

    /**
     * 界面提示消息
     * @param msg
     * @param level
     */
    return function(msg, level) {
        var $tip = $("#qn_tip");
        if ($tip.length > 0) {
            if (level == "success") {
                if (!$tip.hasClass("qn-tip-success")) {
                    $tip.addClass("qn-tip-success");
                }
            } else {
                $tip.removeClass("qn-tip-success");
            }
            $tip.text(msg || "未知错误").fadeIn(500);
            setTimeout(function () {
                $tip.fadeOut(500);
            }, 2000);
        }
    };
});
/**
 * Created by fei on 2015/12/4.
 */
define('wa_RegisterHandler',[],function() {
    "use strict";

    /**
     *自定义事件的事件名
     */
    var HandlerNames = {
        event: "event",
        state: "state",
        result: "result"
    };

    /**
     * 事件处理工具类
     */
    var EventUtils = (function() {
        var listenObj = {};

        /**
         * 添加事件监听
         * @param eventName
         * @param handler
         */
        function addEventListener(eventName, handler) {
            if(typeof listenObj[eventName] === "undefined") {
                listenObj[eventName] = [];
            }
            if(typeof handler === "function") {
                listenObj[eventName].push(handler);
            }
        }

        /**
         * 移除事件监听
         * @param eventName
         * @param handler
         */
        function removeEventListen(eventName, handler) {
            if(!listenObj[eventName]) {
                return;
            }
            if (!handler) {
                listenObj[eventName] = [];
                return;
            }
            for(var i = 0; i < listenObj[eventName].length; i++) {
                //解决内部注册多次事件，执行多次的问题
                if(listenObj[eventName][i].name && (listenObj[eventName][i].name === handler.name)) {
                //if(listenObj[eventName][i] === handler) {
                    listenObj[eventName].splice(i,1);
                    break;
                }
            }
        }

        /**
         * 触发事件
         * @param eventName
         * @param data
         */
        function trigger(eventName,data) {
            if(!listenObj[eventName]) {
                return;
            }
            for(var i = 0; i < listenObj[eventName].length; i++) {
                listenObj[eventName][i](data);
            }
        }

        return {
            addEventListener: addEventListener,
            removeEventListener: removeEventListen,
            trigger: trigger
        }
    })();

    return {
        /**
         * 注册自定义事件处理函数
         * @param handler
         */
        registerEventHandler: function(handler) {
            EventUtils.addEventListener(HandlerNames.event, handler);
        },

        /**
         * 注册自定义状态监听器
         * @param listener
         */
        registerStateListener: function(listener) {
            EventUtils.addEventListener(HandlerNames.state, listener);
        },

        /**
         * 注册自定义结果处理函数
         * @param handler
         */
        registerResultHandler: function(handler) {
            EventUtils.addEventListener(HandlerNames.result, handler);
        },

        /**
         * 触发事件处理函数
         * @param data
         */
        triggerEvent: function(data) {
            EventUtils.trigger(HandlerNames.event, data);
        },

        /**
         * 触发结果处理函数
         * @param data
         */
        triggerResult: function(data) {
            EventUtils.trigger(HandlerNames.result, data)
        },

        /**
         * 触发状态处理函数
         * @param data
         */
        triggerState: function(data) {
            EventUtils.trigger(HandlerNames.state, data);
        },

        /**
         * 移除自定义事件处理函数
         * @param handler
         */
        removeEventHandler: function(handler) {
            EventUtils.removeEventListener(HandlerNames.event, handler);
        },

        /**
         * 移除自定义结果处理函数
         * @param handler
         */
        removeResultHandler: function(handler) {
            EventUtils.removeEventListener(HandlerNames.result, handler);
        }
    }
});
/**
 * Created by mengchen on 2015/8/1.
 */
define('colorBlink',["knockout"],function(ko) {
   ko.bindingHandlers.colorBlink = {
        update: function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var timer;
            var DEFAULT_INTERVAL = 1000;
            var colors = valueAccessor();

            if (typeof colors === "function") {
                colors = colors();
            }

            if (!colors) return;

            if (colors.length === 1) {
                element.style.color = colors[0];
                //element.style.backgroundColor = colors[0];
                if (element.timer) {
                    clearInterval(element.timer);
                }
                return;
            }

            var blinkInterval = allBindings.get("interval") || DEFAULT_INTERVAL;

            var sequence = 0;
            timer = setInterval(function() {
                element.style.color = colors[(sequence++) % colors.length];
                //element.style.backgroundColor = colors[(sequence++) % colors.length];
            }, blinkInterval);

            element.timer = timer;
        }
    };
});

/**
 * 计数器模块
 */
define('wa_Counter',[], function () {
    "use strict";

    var INTERVAL = 1000;

    var timer = null;

    var initValue;
    var value = 0;
    var valueHolder;

    var start = function () {
        if (!timer) {
            initValue = new Date().getTime();
            timer = setInterval(count, INTERVAL);
        }
        return this;
    };

    var count = function () {
        value = parseInt((new Date().getTime() - initValue) / 1000);
        valueHolder && valueHolder(value);
    };

    var stop = function () {
        if (timer) {
            clearInterval(timer);
            timer = null;
        }
        return this;
    };

    var clear = function () {
        value = 0;
        valueHolder && valueHolder(value);
    };

    /**
     * 将秒转换为hh:mm:ss格式
     * @param seconds
     * @returns {string}
     */
    function getTimeFormat(seconds) {
        var hour = parseInt(seconds / 3600);
        if (hour < 10) {
            hour = "0" + hour;
        }
        var minute = parseInt((seconds - hour * 3600) / 60);
        if (minute < 10) {
            minute = "0" + minute;
        }
        var second = parseInt(seconds - hour * 3600 - minute * 60);
        if (second < 10) {
            second = "0" + second;
        }

        return hour + ":" + minute + ":" + second;
    }

    return {
        start: start,
        stop: stop,
        clear: clear,
        valueHolder: function (holder) {
            if (typeof holder === "function") {
                valueHolder = holder;
            }
            return this;
        },
        getTimeFormat: getTimeFormat
    }
});
/**
 * Created by panfei on 2016/7/19.
 */
define('dialog',["jquery", "require"], function($, require) {

    var dialog = {
        buildDialog: function(title, type, callback) {
            $(".ks-dialog-ok").unbind("click");

            require('wa_Vm').dialogType(type);
            $(".ks-dialog-title .title").text(title);

            //提交dialog
            $(".ks-dialog-ok").bind("click", function() {
                if (typeof callback === "function") {
                    callback();
                }
            });

            //取消dialog
            $(".ks-dialog-cancle").bind("click", function() {
                dialog.hide();
            });

            //取消ivr验密，调用保持接回变为双方通话
            $(".ks-dialog-ivr-cancle").bind("click", function() {
                dialog.hide();
                require('wa_Vm').holdReturnEnabled() && require('wa_Extend').holdReturn();
            });

            //ivr协助失败或者成功后，点击返回
            $(".ks-dialog-ivr-return").bind("click", function() {
                dialog.hide();
            });
        },
        hide: function() {
            require('wa_Vm').dialogShow(false);
            require('wa_Vm').ivrConfirmDialogShow(false);
        },
        show: function() {
            require('wa_Vm').dialogShow(true);
            require('wa_Vm').choiceDilogShow(true);
            require('wa_Vm').ivrConfirmDialogResult("load");
        },
        choiceDilogHide: function() {
            require('wa_Vm').choiceDilogShow(false);
        },
        ivrConfirmDialogShow: function() {
            require('wa_Vm').ivrConfirmDialogShow(true);
        }
    }

    return dialog;
});
/**
 * Created by fei on 2015/12/3.
 */
define('wa_ViewModel',["jquery", "knockout", "require", "wa_Defaults", "wa_Constant", "wa_Log", "wa_Tip", "wa_RegisterHandler", "colorBlink", "wa_Counter", "dialog"], function ($, ko, require, defaults, constant, Log, tip, registerHandler, undefined, Counter, dialog) {
    
    CR = window.CR;
    
    function getExtendModule() {
        return require("wa_Extend");
    }
    
    return function () {
        "use strict";
        
        var self = this;
        
        this.sid = "";
        
        //设置是否使用cphone
        this.sipUseCphone = ko.observable();
        
        //设置cphone心跳时间，默认60000ms，1分钟
        this.cphoneInterval = ko.observable(60000);
        
        //webRTC接通挂断box隐藏显示
        this.operBoxDisplay = ko.observable(false);
        
        this.closeOperBox = function () {
            self.operBoxDisplay(false);
        };
        //坐席列表
        this.agentList = ko.observableArray([]);
        
        //技能组列表 --2020/6/2 话路转接功能新增转接技能组
        this.skillList = ko.observableArray([]);
        
        //WA_icon的颜色
        this.colorObj = ko.observable({});
        
        //WA_icon的颜色变化的间隔
        this.icon_interval = ko.observable();
        
        //WA_icon的位置
        this.icon_posRight = ko.observable();
        this.icon_posBottom = ko.observable();
        
        //WA_div的位置
        this.div_posRight = ko.observable();
        this.div_posBottom = ko.observable();
        
        //是否展示软电话登录界面
        this.div_visible = ko.observable();
        
        //是否展示“外显号”一行
        this.outNumbersVisible = ko.observable(true);
        
        //是否展示“外呼号码”一行
        this.outCallNumberVisible = ko.observable(true);
        
        //是否展示"外呼"及“咨询”两行
        this.callConsultVisible = ko.observable(true);
        
        //登录信息是否只读
        this.entIdReadonly = ko.observable(false);
        this.agentIdReadonly = ko.observable(false);
        this.agentPasswordReadonly = ko.observable(false);
        this.agentNumberReadonly = ko.observable(false);
        
        //企业编号
        this.entId = ko.observable("");
        
        this.agentId = ko.observable("");
        this.agentPassword = ko.observable("");
        this.agentNumber = ko.observable("");
        this.forceLogin = ko.observable(false);
        
        //是否记住登录信息
        this.rememberLogin = ko.observable(false);
        
        //坐席当前是否已登录
        this.alreadyLogin = ko.observable(false);
        
        //是否执行登出
        this.handlerLogout = ko.observable(false);
        
        //坐席当前状态
        this.currentState = ko.observable(constant.states.INIT);
        
        //坐席正在状态
        this.doingState = ko.observable(null);
        
        //IVR协助节点
        this.ivrAssists = ko.observableArray([]);
        
        //IVR回转节点
        this.ivrRouters = ko.observableArray([]);
        
        //IVR节点列表
        this.ivrNodeList = ko.observableArray([]);
        
        //展示在页面中的状态
        this.stateShow = ko.computed(function () {
            return (this.doingState() || this.currentState()).desc;
        }, this);
        
        //通知外部监听器状态变化
        this.stateListener = ko.computed(function () {
            var state = this.currentState();
            registerHandler.triggerState(state);
            return state;
        }, this);
        
        //坐席角色（1普通坐席,2班长坐席,3无终端坐席）
        this.agentRole = ko.observable("1");
        
        //外呼的号码
        this.callNumber = ko.observable();
        
        //登录失败信息
        this.loginMessage = ko.observable();
        
        //外显号集合
        this.outNumbers = ko.observableArray([]);
        
        this.outNumberWa = ko.computed(function () {
            var outNumberList;
            
            outNumberList = self.outNumbers().map(function (item) {
                return item.number + item.area;
            });
            
            return outNumberList;
        });
        
        //外显号集合备份
        this.outNumbersTmp = ko.observableArray([]);
        
        //是否展示外显号list
        this.isShowNumbox = ko.observable(false);
        
        //选中的外显号:给phone面板使用
        this.disNumber = ko.observable("");
        
        //选中的外显号:给标准面板使用
        this.disNumberWa = ko.observable("");
        
        //小休子状态集合
        this.awayStatusList = ko.observableArray([]);
        
        //选中的小休状态
        this.awayStatu = ko.observable();
        
        //通话时长(秒)
        this.callDuration = ko.observable(0);
        
        //号码被保护后的原外呼号码
        this.callNumberOri = ko.observable();
        
        //设置号码被保护
        this.numberProtection = ko.observable(false);
        
        //咨询、单步转移、监听弹出框的配置参数
        this.dialogObj = ko.observable({
            title: "",
            isChecked: ko.observable(""),
            inputTitle: "",
            insideContent: "",
            outsideContent: "",
            skillGroupContent: "",
            toAgent: ko.observable(),
            handleName: ""
        });
        
        //ivr节点弹出框的配置参数
        this.ivrDialogObj = ko.observable({
            title: "",
            toIvrNode: ko.observable(),
            handleName: ""
        });
        
        //切换中心的配置参数
        this.centreDialogObj = ko.observable({
            title: "",
            text: ko.observable(),
            handleName: ""
        });
        
        //ivr输入身份证/卡号验密
        this.ivrAssistsCardId = ko.observable("");
        
        //irv协助显示输入密码框
        this.ivrObjExit = ko.observable(false);
        
        //irv协助卡号--确认按钮
        this.ivrCardBtnDisabled = ko.observable(true);
        
        //ivr验证身份证/卡号格式
        this.checkIvrCard = ko.computed(function () {
            var reg = /^\d{0,21}[\dXx]$/;
            if (self.ivrAssistsCardId()) {
                if (reg.test(self.ivrAssistsCardId())) {
                    self.ivrCardBtnDisabled(false);
                    return "";
                } else {
                    self.ivrCardBtnDisabled(true);
                    return "您输入的卡号有误，请重新输入";
                }
            } else {
                self.ivrCardBtnDisabled(true);
            }
        });
        
        //ivr协助卡号验密类型跟踪
        this.checkIvrCardIdType = ko.observable(0);
        
        //弹出框的类型
        this.dialogType = ko.observable();
        
        //弹出框展示
        this.dialogShow = ko.observable(false);
        
        //选择框是否展示
        this.choiceDilogShow = ko.observable(true);
        
        //ivr验证框是否展示
        this.ivrConfirmDialogShow = ko.observable(false);
        
        //ivr验证结果展示
        this.ivrConfirmDialogResult = ko.observable("");
        
        //聊天框确认按钮禁用情况
        this.dialogBtnDisabled = ko.computed(function () {
            switch ( self.dialogType() ) {
                case "consult":
                case "singleTransfer":
                case "observe":
                    return !self.dialogObj().toAgent();
                case "away":
                    return !self.awayStatu();
                case "assistIVR":
                case "routerToIVR":
                    return !self.ivrDialogObj().toIvrNode();
                default:
                    break;
            }
        }, this);
        
        //是否使用面板
        this.ui = ko.observable(true);
        
        this.robotAgentList = ko.observableArray([]);
        this.selectedRobotAgent = ko.observable();
        
        // 选择外显号码方式（手动或者智能选择）
        this.outCallType = ko.observable('manualSelect');
        
        // 禁用手动选择
        this.outCallTypeCss = ko.pureComputed(function () {
            return self.outCallType() != 'manualSelect';
        });
        
        //通话时长(hh:mi:ss)
        this.callDurationShow = ko.computed(function () {
            return Counter.getTimeFormat(this.callDuration());
        }, this);
        
        /**
         * 登录按钮文字展示
         */
        this.loginButtonText = ko.computed(function () {
            return (this.doingState() === constant.states.LOGINING) ? "登录中" : "登录";
        }, this);
        
        /**
         * 登录：在未登录及非登录中时可用(防止并发提交)
         */
        this.loginEnabled = ko.pureComputed(function () {
            return !(this.doingState() === constant.states.LOGINING) && !this.alreadyLogin();
        }, this);
        
        /**
         * 外呼：置忙时可用
         */
        this.callEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.BUSY);
        }, this);
        
        /**
         * 内呼：置忙时可用
         */
        this.callInternalEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.BUSY);
        }, this);
        
        /**
         * 挂断：坐席接通、双方通话、内呼接通、会议中、监听、被咨询、多人会议中可用
         */
        this.hangupEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.AGENT_CONNECTED ||
                this.currentState() == constant.states.CONNECTED ||
                this.currentState() == constant.states.INTERNAL_CONNECTED ||
                //this.currentState() == constant.states.HOLD ||
                this.currentState() == constant.states.CONFERENCED ||
                this.currentState() == constant.states.OBSERVED ||
                this.currentState() == constant.states.CONSULTED_B ||
                this.currentState() == constant.states.MP_CONFERENCE ||
                this.currentState() == constant.states.MP_CONFERENCING ||
                this.currentState() == constant.states.MP_CONFERENCE_ALERTING_TP ||
                this.currentState() == constant.states.MP_CONFERENCE_ALERTING_OP ||
                this.currentState() == constant.states.CRYPTOLALIA
            );
        }, this);
        
        this.hangupDisabled = ko.pureComputed(function () {
            return this.doingState() || (this.currentState() == constant.states.AGENT_ALERTING ||
                this.currentState() == constant.states.CUSTOM_ALERTING ||
                //this.currentState() == constant.states.CONSULT_ALERTING ||
                this.currentState() == constant.states.CONSULT_B_ALERTING ||
                this.currentState() == constant.states.OBSERVE_ALERTING ||
                this.currentState() == constant.states.AGENT_ALERTING ||
                this.currentState() == constant.states.INTERNAL_ALERTING ||
                this.currentState() == constant.states.TRANSFER_ALERTING
            );
        }, this);
        
        /**
         * 置闲：置忙，事后整理，小休时可用
         */
        this.readyEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.BUSY || this.currentState() == constant.states.ACW || this.currentState() == constant.states.AWAY || this.currentState() == constant.states.WORKING);
        }, this);
        
        /**
         * 置忙：置闲，事后整理,小休时可用
         */
        this.busyEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.READY || this.currentState() == constant.states.ACW || this.currentState() == constant.states.AWAY || this.currentState() == constant.states.WORKING);
        }, this);
        
        /**
         * 工作状态: 置闲，置忙, 事后整理, 小休时可用
         */
        this.workingEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.READY || this.currentState() == constant.states.BUSY || this.currentState() == constant.states.AWAY || this.currentState() == constant.states.ACW);
        }, this);
        
        /**
         * 小休: 置忙，置闲，事后整理，小休时可用
         */
        this.awayEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.BUSY || this.currentState() == constant.states.READY || this.currentState() == constant.states.ACW || this.currentState() == constant.states.AWAY || this.currentState() == constant.states.WORKING);
        }, this);
        
        /**
         * 登出：置忙，置闲，事后整理，正在呼叫,小休时可用
         */
        this.logoutEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.BUSY ||
                this.currentState() == constant.states.READY ||
                this.currentState() == constant.states.ACW ||
                this.currentState() == constant.states.CONNECTING ||
                this.currentState() == constant.states.AWAY
            );
        }, this);
        
        /**
         * 重置：目前一直可用
         */
        this.resetEnabled = ko.observable(true);
        
        /**
         * 保持：双方通话时可用
         */
        this.holdEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONNECTED || this.currentState() == constant.states.CRYPTOLALIA);
        }, this);
        
        /**
         * 保持接回：保持时可用
         */
        this.holdReturnEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.HOLD);
        }, this);
        
        /**
         * 咨询：双方通话时可用
         */
        this.consultEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONNECTED || this.currentState() == constant.states.CRYPTOLALIA);
        }, this);
        
        /**
         * 咨询接回：咨询振铃时可用，以前是咨询接通可用
         */
        this.consultReturnEnabled = ko.pureComputed(function () {
            //return !this.doingState() && (this.currentState() == constant.states.CONSULTED);
            return !this.doingState() && ((this.currentState() == constant.states.CONSULT_ALERTING) || (this.currentState() == constant.states.CONSULTED));
        }, this);
        
        /**
         * 会议：咨询方咨询通话时可用
         */
        this.conferenceEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONSULTED);
        }, this);
        
        /**
         * 转移：咨询通话时可用
         */
        this.transferEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONSULTED);
        }, this);
        
        /**
         * 单步转移：双方通话时可用
         */
        this.singleTransferEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONNECTED || this.currentState() == constant.states.CRYPTOLALIA);
        }, this);
        
        /**
         * 单步转移：双方通话时可用
         */
        this.singleConferenceEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONNECTED || this.currentState() == constant.states.CRYPTOLALIA);
        }, this);
        
        /**
         * 监听：班长坐席置忙时可用
         */
        this.observeEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.agentRole() == 2 && this.currentState() == constant.states.BUSY);
            //return !this.doingState() && (this.currentState() == constant.states.BUSY);
            // return true;
        }, this);
        
        /**
         * 强插：班长坐席监听中可用
         */
        this.insertEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.agentRole() == 2 && (this.currentState() == constant.states.OBSERVED || this.currentState() == constant.states.LAUNCH_CRYPTOLALIA));
        }, this);
        
        /**
         * 强拆：班长坐席监听中可用
         */
        this.forceAbortEnabled = ko.pureComputed(function () {
            return !this.doingState() &&
                (this.agentRole() == 2 && (this.currentState() == constant.states.OBSERVED || this.currentState() == constant.states.LAUNCH_CRYPTOLALIA));
        }, this);
        
        /**
         * 开启密语：班长坐席监听中可用
         */
        this.startCryptolaliaEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.agentRole() == 2 && this.currentState() == constant.states.OBSERVED);
        }, this);
        
        /**
         * 关闭密语：班长坐席在密语中可以使用
         */
        this.stopCryptolaliaEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.agentRole() == 2 && this.currentState() == constant.states.LAUNCH_CRYPTOLALIA);
        }, this);
        
        
        /**
         * 全拆：班长坐席会议中可用
         */
        this.fullAbortEnabled = ko.pureComputed(function () {
            return this.currentState() == constant.states.OBSERVED;
            //return !this.doingState() && (this.agentRole() == 2 && this.currentState() == constant.states.CONFERENCED);
        }, this);
        
        /**
         * IVR协助服务：双方通话时可用
         */
        this.assistIVREnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONNECTED || this.currentState() == constant.states.CRYPTOLALIA);
        }, this);
        
        /**
         * 转IVR：双方通话时可用
         */
        this.routerToIVREnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState() == constant.states.CONNECTED || this.currentState() == constant.states.CRYPTOLALIA);
        }, this);
        
        /**
         * 设置随路数据：目前一直可用
         */
        this.setCallDataEnabled = ko.pureComputed(function () {
            return true;
        }, this);
        
        /**
         * 获取随路数据：目前一直可用
         */
        this.getCallDataEnabled = ko.pureComputed(function () {
            return true;
        }, this);
        
        /**
         * 在密语的时候：高级话路按钮禁用
         */
        this.highLevelCallDisabled = ko.pureComputed(function () {
            return this.currentState() == constant.states.CRYPTOLALIA;
        }, this);
        
        /**
         * 四方会议：会议时可用
         */
        this.joinConferenceEnabled = ko.pureComputed(function () {
            return !this.doingState() && (this.currentState().key == constant.states.CONFERENCED.key) && WebAgent.isUseMpConference;
        }, this);
        
        this.joinConferenceDisabled = ko.pureComputed(function () {
            return !this.doingState() && (this.meetingNum() == this.maxMeetingNum);
        }, this);
        
        // 是否静音
        this.isMute = ko.observable(false);
        
        this.CR = ko.observable();
        
        /**
         * 是否展示开启静音的图标
         */
        this.setMuteEnabled = ko.pureComputed(function () {
            return !this.doingState()
                && this.CR()
                && !this.isMute()
                && (
                    this.currentState() != constant.states.READY &&
                    this.currentState() != constant.states.WORKING &&
                    this.currentState() != constant.states.BUSY &&
                    this.currentState() != constant.states.AWAY &&
                    this.currentState() != constant.states.ACW &&
                    this.currentState() != constant.states.INTERNAL_CONNECTED &&
                    this.currentState() != constant.states.INTERNAL_ALERTING
                );
        }, this);
        
        /**
         * 是否展示关闭静音的图标
         */
        this.stopMuteEnabled = ko.pureComputed(function () {
            return !this.doingState()
                && this.CR()
                && this.isMute()
                && (
                    this.currentState() != constant.states.READY &&
                    this.currentState() != constant.states.WORKING &&
                    this.currentState() != constant.states.BUSY &&
                    this.currentState() != constant.states.AWAY &&
                    this.currentState() != constant.states.ACW
                );
        }, this);
        
        //隐藏显示可选外显号
        this.toggleNumBox = function () {
            if (self.outCallType() == 'intelSelect') {
                return;
            }
            self.isShowNumbox(!self.isShowNumbox());
        };
        //查询外显号码
        this.searchNum = function () {
            var outNumber;
            var search = "" + self.searchNumData();
            if (search.length > 1) {
                outNumber = this.outNumbersTmp().filter(function (p1) {
                    return p1.number.includes(search);
                });
                this.outNumbers(outNumber.slice());
            } else {
                this.outNumbers(this.outNumbersTmp().slice());
            }
        };
        
        this.chooseDisnum = function () {
            self.disNumber(self.disNumberWa());
        };
        
        //选择外显号码
        this.chooseOutNum = function (data) {
            self.disNumber(data.number + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + data.area);
            self.disNumberWa(data.number + data.area);
            self.isShowNumbox(false);
        };
        
        /**
         * 登录
         * @returns {boolean}
         */
        this.login = function () {
            var result = getExtendModule().login({
                entId: self.entId(),
                agentId: self.agentId(),
                agentNumber: self.agentNumber(),
                agentPassword: self.agentPassword(),
                isForce: self.forceLogin()
            });
            
            if (result.code == 0) {
                Log.log("[webAgent-wa] 登录命令发送成功" + (self.forceLogin() ? "(强制登录)" : ""));
            } else {
                Log.warn("[webAgent-wa]:" + result.msg);
                self.loginMessage(result.msg);
            }
            
            return false;
        };
        
        /**
         * 登出
         */
        this.logout = function () {
            var result = getExtendModule().logout();
            
            if (result.code == 0) {
                Log.log("[webAgent-wa] 登出命令发送成功");
            } else {
                Log.warn("[webAgent-wa]:" + result.msg);
            }
        };
        
        /**
         * 置忙
         */
        this.setBusy = function () {
            var result = getExtendModule().setBusy();
            
            if (result.code == 0) {
                Log.log("[webAgent-wa] 置忙命令发送成功");
            } else {
                Log.warn("[webAgent-wa]:" + result.msg);
            }
        };
        
        /**
         * 小休
         */
        this.setAway = function () {
            if (!self.awayEnabled()) {
                Log.warn("[webAgent-wa] away denied");
                return;
            }
            
            self.awayStatu("");
            dialog.show();
            
            dialog.buildDialog("请选择小休状态：", "away", function () {
                var result = getExtendModule().setAway(self.awayStatu());
                
                if (result.code === 0) {
                    Log.log("[webAgent-wa] 小休命令发送成功");
                } else {
                    Log.warn("[webAgent-wa]:" + result.msg);
                    tip(result.msg);
                }
            });
        };
        
        /**
         * 置闲
         */
        this.setReady = function () {
            var result = getExtendModule().setReady();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 置闲命令发送成功");
            } else {
                Log.warn("[webAgent-wa]" + result.msg);
            }
        };
        
        /**
         * 外呼
         */
        this.makeCall = function () {
            
            var disNumbers = self.disNumber();
            //过滤空格
            
            if (self.callNumber()) {
                var callNumber = self.callNumber().replace(/\s/g, '');
                self.callNumber(callNumber);
            }
           var result = getExtendModule().makeCall({
                outCallNumber: self.callNumber(),
                disNumber: disNumbers.match(/\d+/)[0],
                isIntellectCall: !(self.outCallType() == 'manualSelect'),
                mediaType: WebAgent.mediaType,
            });
            
            result.then(function(res){
                Log.log("[webAgent-wa] 外呼命令发送成功");
            },function(res){
                Log.warn("[webAgent-wa]" + res.msg);
                tip(res.msg);
            })
        };
        
        /**
         * 内呼
         */
        this.makeCallInternal = function () {
            var result = getExtendModule().makeCallInternal({
                inCallNumber: self.callNumber()
            });
            
            if (result.code === 0) {
                Log.log("[webAgent-wa]内呼命令发送成功");
                self.currentState(constant.states.CONNECTING);
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
                result.code == -2 && tip(result.msg);
            }
        };
        
        /**
         * 挂断
         */
        this.hangup = function () {
            var result = getExtendModule().hangup();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 挂断命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 重置
         */
        this.reset = function () {
            var result = getExtendModule().reset();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa]重置命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 保持
         */
        this.hold = function () {
            if (self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] hold denied");
                return;
            }
            var result = getExtendModule().hold();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa]保持命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 保持接回
         */
        this.holdReturn = function () {
            var result = getExtendModule().holdReturn();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa]保持接回命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 获取坐席列表
         */
        this.agentGetList = function (workType) {
            var result = getExtendModule().agentGetList(workType);
            
            if (result.code === 0) {
                Log.log("[webAgent-wa]获取坐席列表命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 选择坐席
         * @param data
         */
        this.selectAgent = function (data) {
            self.dialogObj().toAgent(data.agentId);
        };
        
        /**
         * 选择技能组
         * @param data
         */
        this.selectSkill = function (data) {
            self.dialogObj().toAgent(data.skillName);
        };
        
        /**
         * 切换咨询、单步转移内线
         * @returns {boolean}
         */
        this.toggleInside = function () {
            self.agentGetList('1');
            self.dialogObj().toAgent('');
            return true;
        };
        
        /**
         * 切换咨询、单步转移外线
         * @returns {boolean}
         */
        this.toggleOutside = function () {
            self.dialogObj().toAgent('');
            return true;
        };
        
        /**
         * 咨询
         */
        this.consult = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.consultEnabled() || self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] consult denied");
                return;
            }
            
            self.dialogObj({
                title: "咨询坐席",
                isChecked: ko.observable("1"),
                inputTitle: "请输入要咨询的号码",
                insideContent: "内线",
                outsideContent: "外线",
                skillGroupContent: "技能组",
                workingContent: "内部求助",
                toAgent: ko.observable(""),
                handleName: "consult"
            });
            
            self.agentGetList('1'); //咨询时，默认咨询内线，获取坐席列表
            dialog.show();
            
            dialog.buildDialog("咨询坐席：", "consult", function () {
                var result = getExtendModule().consult({
                    consultAgent: self.dialogObj().toAgent(),
                    type: self.dialogObj().isChecked()
                });
                if (result.code === 0) {
                    dialog.hide();
                    Log.log("[webAgent-wa] 咨询命令发送成功");
                } else {
                    Log.warn("[webAgent-wa] " + result.msg);
                    tip(result.msg);
                }
            });
        };
        
        /**
         * 咨询接回
         */
        this.consultReturn = function () {
            var result = getExtendModule().consultReturn();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 咨询接回命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 转移
         * 转移成功后，原坐席将收到挂断，变为事后整理；目标坐席将收到转移事件，变为双方通话
         */
        this.transfer = function () {
            var result = getExtendModule().transfer();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 转移命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 单步转移(不经过咨询直接转移)
         */
        this.singleTransfer = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.singleTransferEnabled() || self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] single transfer denied");
                return;
            }
            
            self.dialogObj({
                title: "单步转移坐席",
                isChecked: ko.observable("1"),
                inputTitle: "请输入要转移的号码",
                insideContent: "内线",
                outsideContent: "外线",
                skillGroupContent: "技能组",
                toAgent: ko.observable(""),
                handleName: "singleTransfer"
            });
            
            self.agentGetList('1'); //单步转移时，默认单转内线，获取坐席列表
            dialog.show();
            
            dialog.buildDialog("单步转移坐席：", "singleTransfer", function () {
                
                var result = getExtendModule().singleTransfer({
                    transferTo: self.dialogObj().toAgent(),
                    type: self.dialogObj().isChecked()
                });
                
                if (result.code === 0) {
                    dialog.hide();
                    Log.log("[webAgent-wa] 单步转移命令发送成功");
                } else {
                    Log.warn("[webAgent-wa] " + result.msg);
                    tip(result.msg);
                }
            });
        };
        
        
        /**
         * 单步会议(不经过咨询直接转移)
         */
        this.singleConference = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.singleConferenceEnabled() || self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] single conference denied");
                return;
            }
            
            self.dialogObj({
                title: "单步会议",
                isChecked: ko.observable("1"),
                inputTitle: "请输入加入会议的号码",
                insideContent: "坐席",
                outsideContent: "号码",
                skillGroupContent: "技能组",
                workingContent: "内部求助",
                toAgent: ko.observable(""),
                handleName: "singleConference"
            });
            
            self.agentGetList('1'); //单步转移时，默认单转内线，获取坐席列表
            dialog.show();
            
            dialog.buildDialog("单步会议：", "singleConference", function () {
                
                var result = getExtendModule().singleConference({
                    transferTo: self.dialogObj().toAgent(),
                    type: self.dialogObj().isChecked()
                });
                
                if (result.code === 0) {
                    dialog.hide();
                    Log.log("[webAgent-wa] 单步会议命令发送成功");
                } else {
                    Log.warn("[webAgent-wa] " + result.msg);
                    tip(result.msg);
                }
            });
        };
        
        
        /**
         * 监听 / 拦截
         */
        this.observe = function (workType) {
            
            if (!self.observeEnabled()) {
                Log.warn("[webAgent-wa] observe denied");
                return;
            }
            
            self.dialogObj({
                title: ko.observable("监听坐席"),
                inputTitle: "请输入要监听的坐席号码:",
                observe: "监听",
                intercept: "拦截",
                toAgent: ko.observable("1"),
                handleName: "observe",
                isChecked: ko.observable("1")
            });
            
            self.agentGetList(workType);
            dialog.show();
            
            dialog.buildDialog("监听坐席：", "observe", function () {
                let isChecked = self.dialogObj().isChecked();
                if (isChecked == 1) {
                    // 监听
                    var result = getExtendModule().observe({
                        observeAgentId: self.dialogObj().toAgent()
                    });
                } else if (isChecked == 0) {
                    // 拦截
                    var result = getExtendModule().intercept({
                        observeAgentId: self.dialogObj().toAgent()
                    });
                }
                
                if (result.code === 0) {
                    dialog.hide();
                    Log.log("[webAgent-wa] 监听命令发送成功");
                } else {
                    Log.warn("[webAgent-wa] " + result.msg);
                    tip(result.msg);
                }
            });
        };
        
        /**
         * 强插
         */
        this.forceInsert = function () {
            var result = getExtendModule().forceInsert();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa]强插命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 强拆
         */
        this.forceAbort = function () {
            var result = getExtendModule().forceAbort();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 强拆命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 全拆
         */
        this.fullAbort = function () {
            var result = getExtendModule().fullAbort();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 全拆命令发送成功");
            } else {
                Log.warn("[webAgent-wa] ", result.msg);
            }
        };
        
        /**
         * 会议
         */
        this.conference = function () {
            var result = getExtendModule().conference();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 会议命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        //选择IVR节点
        this.selectIvrNode = function (data) {
            self.ivrDialogObj().toIvrNode(data);
        };
        
        /**
         * IVR协助
         */
        this.assistIVR = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.assistIVREnabled() || self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] assist IVR denied");
                return;
            }
            
            self.ivrNodeList(self.ivrAssists());
            self.ivrObjExit(false);
            self.ivrDialogObj({
                title: "IVR节点",
                toIvrNode: ko.observable(""),
                handleName: "assistIVR"
            });
            
            dialog.show();
            
            dialog.buildDialog("IVR节点：", "assistIVR", function () {
                if (self.dialogBtnDisabled()) {
                    return;
                } else {
                    self.ivrObjExit(true);
                    self.checkIvrCardIdType(0);
                    //ivr验密--输入卡号
                    dialog.buildDialog("IVR节点：", "assistIVR", self.ivrAssistsExt);
                }
            });
        };
        
        //ivr验密--直接协助
        this.ivrAssistsDirectHelp = function () {
            self.checkIvrCardIdType(1);
            self.ivrAssistsCardId("");
            this.ivrAssistsExt();
        };
        
        //调IVR协助接口
        this.ivrAssistsExt = function () {
            if (!self.checkIvrCardIdType() && self.ivrCardBtnDisabled()) {
                return;
            }
            
            var result = getExtendModule().assistIVR({
                key: "ivrAssist",
                value: self.ivrDialogObj().toIvrNode().key,
                type: self.checkIvrCardIdType(),
                cardId: self.ivrAssistsCardId()
            });
            
            if (result.code === 0) {
                dialog.choiceDilogHide();
                dialog.ivrConfirmDialogShow();
                self.ivrObjExit(false);
                self.ivrConfirmDialogResult("load");
                Log.log("[webAgent-wa] IVR协助服务命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * IVR回转
         */
        this.routerToIVR = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.routerToIVREnabled() || self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] router to IVR denied");
                return;
            }
            
            self.ivrNodeList(self.ivrRouters());
            self.ivrDialogObj({
                title: "IVR节点",
                toIvrNode: ko.observable(""),
                handleName: "routerToIVR"
            });
            
            dialog.show();
            
            dialog.buildDialog("IVR节点：", "routerToIVR", function () {
                
                if (self.dialogBtnDisabled()) {
                    return;
                }
                
                var param = "ivrRouter=" + self.ivrDialogObj().toIvrNode().key; //拼接参数
                
                var result = getExtendModule().routerToIVR(param);
                
                if (result.code === 0) {
                    dialog.hide();
                    Log.log("[webAgent-wa] 转IVR命令发送成功");
                } else {
                    Log.warn("[webAgent-wa] " + result.msg);
                }
            });
        };
        
        //接听按钮点击一次就置灰
        this.hasAnswerBtnClicked = ko.observable(false);
        // 接听按钮可以点击：外呼坐席振铃，被咨询坐席振铃，单步转移振铃, 被内呼振铃，监听振铃, 转移振铃, 发起方内呼振铃,单步会议,四方会议
        this.answered = ko.pureComputed(function () {
            return !this.doingState() &&
                (
                    this.currentState() == constant.states.AGENT_ALERTING ||
                    this.currentState() == constant.states.CONSULT_B_ALERTING ||
                    this.currentState() == constant.states.TRANSFER_ALERTING ||
                    this.currentState() == constant.states.OBSERVE_ALERTING ||
                    this.currentState() == constant.states.TRANSFER_ALERTING ||
                    this.currentState() == constant.states.INTERNAL_ALERTING ||
                    this.currentState() == constant.states.MP_CONFERENCE_ALERTING_OP ||
                    this.currentState() == constant.states.MP_CONFERENCE_ALERTING_TP ||
                    this.currentState() == constant.states.SINGLE_STEP_CONFERENCE_ALERTING
                )
                && !this.hasAnswerBtnClicked();
        }, this);
        
        // 设置自动应答
        this.autoAnswer = ko.observable(false);
        this.callInTip = ko.observable("网路语音电话");
        this.setAutoAnswer = function () {
            console.log('设置自动应答：' + this.autoAnswer());
            CR.setAutoAnswer(this.autoAnswer());
        };
        
        this.answerVerto = function () {
            //WebAgent.sipUseWebRTC=true;
            if (this.hasAnswerBtnClicked()) {
                return;
            }
            var res = CR.answer();
            if (res.code === 0) {
                this.hasAnswerBtnClicked(true);
            }
        };
        
        this.hangupVerto = function () {
            if (!self.hangupEnabled()) {
                console.log('hangup denied');
            }
            CR.hangup();
        };
        
        /**
         * 设置电话图标的颜色
         */
        this.colors = ko.computed(function () {
            if (!self.colorObj()) {
                return [defaults.iconColor];
            }
            switch ( self.currentState() && self.currentState().key ) {
                case "INIT" :
                    return self.colorObj().init || [defaults.iconColor];
                case "READY" :
                    return self.colorObj().ready || [defaults.iconColor];
                case "AGENT_ALERTING" :
                case "CUSTOM_ALERTING" :
                case "INTERNAL_ALERTING" :
                case "CONSULT_ALERTING" :
                case "CONSULT_B_ALERTING" :
                case "TRANSFER_ALERTING" :
                case "OBSERVE_ALERTING" :
                    return self.colorObj().altering || [defaults.iconColor];
                case "CONNECTED" :
                case "INTERNAL_CONNECTED":
                case "CONSULTED":
                case "CONSULTED_B":
                case "CONFERENCED":
                    return self.colorObj().connected || [defaults.iconColor];
                default :
                    return self.colorObj().others || [defaults.iconColor];
            }
        }, this);
        
        this.searchNumData = ko.observable();
        
        /**
         * 当前会议的人数
         */
        this.meetingNum = ko.observable(0);
        
        /**
         * 这个版本的多人会议的最大人数，统一管理，方便修改
         */
        this.maxMeetingNum = ko.observable(4);
        
        /**
         * 创建多人会议
         * 多人会议：参会人数大于普通会议的人数
         */
        this.joinConference = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.joinConferenceEnabled()) {
                Log.warn("[webAgent-wa] Join Conference denied");
                return;
            }
            
            self.dialogObj({
                title: "加入会议的坐席",
                isChecked: ko.observable("1"),
                inputTitle: "请输入要加入会议的号码",
                insideContent: "内线",
                outsideContent: "外线",
                skillGroupContent: "技能组",
                toAgent: ko.observable(""),
                handleName: "joinConference"
            });
            
            self.agentGetList('1');
            dialog.show();
            
            dialog.buildDialog("加入会议：", "joinConference", function () {
                var result = getExtendModule().joinConference({
                    consultAgent: self.dialogObj().toAgent(),
                    type: self.dialogObj().isChecked()
                });
                if (result.code === 0) {
                    dialog.hide();
                    Log.log("[webAgent-wa] 加入会议命令发送成功");
                } else {
                    Log.warn("[webAgent-wa] " + result.msg);
                    tip(result.msg);
                }
            });
        };
        this.toggleDialogTitle = function () {
            self.dialogObj().title(self.dialogObj().isChecked() == 1 ? '监听坐席' : '拦截坐席');
            return true;
        };
        /**
         * 开启密语
         */
        this.startCryptolalia = function () {
            if (!self.startCryptolaliaEnabled()) {
                Log.warn("[webAgent-wa] start cryptolalia denied");
                return;
            }
            var result = getExtendModule().startCrypto();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 开启密语命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        /**
         * 关闭密语
         */
        this.stopCryptolalia = function () {
            if (!self.stopCryptolaliaEnabled()) {
                Log.warn("[webAgent-wa] stop cryptolalia denied");
                return;
            }
            var result = getExtendModule().stopCrypto();
            
            if (result.code === 0) {
                Log.log("[webAgent-wa] 开启密语命令发送成功");
            } else {
                Log.warn("[webAgent-wa] " + result.msg);
            }
        };
        
        // 是否获取工作状态的坐席
        this.isGetWorkingAgent = ko.observable(false);
        
        // 工作坐席列表
        this.workingAgentList = ko.observableArray([]);
        
        /**
         * 咨询切换radio为工作状态
         */
        this.toggleWorking = function () {
            self.isGetWorkingAgent(true);
            self.agentGetList('5');
            self.dialogObj().toAgent('');
            return true;
        };
        
        /**
         * 设置静音/关闭静音
         * @param isSetMute 1 开启静音 / 2 关闭静音
         */
        this.setMute = function (isSetMute) {
            let setMuteEnabled = isSetMute ? self.setMuteEnabled() : self.stopMuteEnabled();
            if (!setMuteEnabled) {
                Log.warn("[webAgent-wa] set mute denied");
                return;
            }
            self.isMute(!self.isMute());
            if (!self.isMute()) {
                $(".video-btn > li").eq(0).html('<div class="icon-btn iconfont">&#xe61a</div><p>静音</p>');
                $(".video-btn li:eq(0)").removeClass("hold-disabled");
            } else {
                $(".video-btn > li").eq(0).html('<div class="icon-btn iconfont">&#xe665</div><p>取消静音</p>');
                $(".video-btn li:eq(0)").addClass("hold-disabled");
            }
            window.CR.setMute();
        };
        
        /**
         * 转中心
         */
        this.changeCentre = function () {
            //不允许操作时直接return，不弹dialog
            if (!self.routerToIVREnabled() || self.highLevelCallDisabled()) {
                Log.warn("[webAgent-wa] change centre denied");
                return;
            }
            
            self.centreDialogObj({
                title: "请输入提供给其他中心坐席的留言",
                text: ko.observable(""),
                handleName: "changeCentre"
            });
            
            dialog.show();
            
            dialog.buildDialog("转中心：", "changeCentre", function () {
                let number = self.callNumber().split(':');
                $.ajax({
                    url: WebAgent.changeCentreUrl + "/adapter/number/setCallData",
                    type: "post",
                    data: {
                        number: number.length === 1 ? number[0] : number[1],
                        callData: self.centreDialogObj().text(),
                    },
                    traditional: true,
                    global: false,
                    dataType: "json",
                    success: function (res) {
                        if (res.result == "00000") {
                            callback();
                        }
                    }
                });
                
                function callback() {
                    var param = "kzhzj";
                    var result = getExtendModule().routerToIVR(param);
                    if (result.code === 0) {
                        dialog.hide();
                        Log.log("[webAgent-wa] 转中心命令发送成功");
                    } else {
                        Log.warn("[webAgent-wa] " + result.msg);
                    }
                }
            });
        };
    };
});

/**
 * Created by fei on 2015/12/3.
 */
define('wa_Vm',["wa_ViewModel"], function(ViewModel){
    return new ViewModel();
});
/**
 * 信息存储模块
 */
define('wa_Storage',["wa_Vm"], function(vm) {
    "use strict";

    var KEYS = {
        ENT_ID: "WA_ENTID",
        AGENT_ID: "WA_AGENTID",
        AGENT_NUMBER: "WA_AGENT_NUMBER",
        AGENT_PASSWORD: "WA_AGENT_PASSWORD",
        REMEMBER_LOGIN: "WA_REMEMBER_LOGIN"
    };

    var ls = window.localStorage;
    
    function saveLoginInfo() {
        ls.setItem(KEYS.ENT_ID, vm.entId());
        ls.setItem(KEYS.AGENT_ID, vm.agentId());
        ls.setItem(KEYS.AGENT_NUMBER, vm.agentNumber());
        ls.setItem(KEYS.AGENT_PASSWORD, vm.agentPassword());
        ls.setItem(KEYS.REMEMBER_LOGIN, vm.rememberLogin());
    }
    
    function clearLoginInfo() {
        ls.removeItem(KEYS.ENT_ID);
        ls.removeItem(KEYS.AGENT_ID);
        ls.removeItem(KEYS.AGENT_NUMBER);
        ls.removeItem(KEYS.AGENT_PASSWORD);
        ls.removeItem(KEYS.REMEMBER_LOGIN);
    }
    
    function resumeLoginInfo() {
        vm.entId(ls.getItem(KEYS.ENT_ID) ||  vm.entId());
        vm.agentId(ls.getItem(KEYS.AGENT_ID) || vm.agentId());
        vm.agentNumber(ls.getItem(KEYS.AGENT_NUMBER) || vm.agentNumber());
        vm.agentPassword(ls.getItem(KEYS.AGENT_PASSWORD) || vm.agentPassword());
        vm.rememberLogin(ls.getItem(KEYS.REMEMBER_LOGIN));
    }

    return {
        saveLoginInfo: saveLoginInfo,
        clearLoginInfo: clearLoginInfo,
        resumeLoginInfo: resumeLoginInfo
    };
});
define('area_code',[],function () {
    var areaCode3={
        "010": "北京",
        "021": "上海",
        "022": "天津",
        "023": "重庆",
        "028": "四川 成都",
        "024": "辽宁 沈阳",
        "025": "江苏 南京",
        "020": "广东 广州",
        "027": "湖北 武汉",
        "029": "陕西 西安"
    };
    var areaCode4={
        "0311": "河北 石家庄",
        "0312": "河北 保定",
        "0314": "河北 承德",
        "0310": "河北 邯郸",
        "0315": "河北 唐山",
        "0335": "河北 秦皇岛",
        "0317": "河北 沧州",
        "0318": "河北 衡水",
        "0316": "河北 廊坊",
        "0319": "河北 邢台",
        "0313": "河北 张家口",
        "0351": "山西 太原",
        "0355": "山西 长治",
        "0352": "山西 大同",
        "0356": "山西 晋城",
        "0354": "山西 晋中",
        "0357": "山西 临汾",
        "0358": "山西 吕梁",
        "0349": "山西 朔州",
        "0350": "山西 忻州",
        "0359": "山西 运城",
        "0353": "山西 阳泉",
        "0471": "内蒙古 呼和浩特",
        "0472": "内蒙古 包头",
        "0476": "内蒙古 赤峰",
        "0477": "内蒙古 鄂尔多斯",
        "0470": "内蒙古 呼伦贝尔",
        "0475": "内蒙古 通辽",
        "0474": "内蒙古 乌兰察布",
        "0473": "内蒙古 乌海",
        "0482": "内蒙古 兴安盟",
        "0411": "辽宁 大连",
        "0412": "辽宁 鞍山",
        "0415": "辽宁 丹东",
        "0413": "辽宁 抚顺",
        "0416": "辽宁 锦州",
        "0417": "辽宁 营口",
        "0414": "辽宁 本溪",
        "0428": "辽宁 朝阳",
        "0418": "辽宁 阜新",
        "0429": "辽宁 葫芦岛",
        "0419": "辽宁 辽阳",
        "0427": "辽宁 盘锦",
        "0410": "辽宁 铁岭",
        "0431": "吉林 长春",
        "0432": "吉林 吉林",
        "0436": "吉林 白城",
        "0439": "吉林 白山",
        "0437": "吉林 辽源",
        "0434": "吉林 四平",
        "0438": "吉林 松原",
        "0435": "吉林 通化",
        "0451": "黑龙江 哈尔滨",
        "0459": "黑龙江 大庆",
        "0452": "黑龙江 齐齐哈尔",
        "0454": "黑龙江 佳木斯",
        "0457": "黑龙江 大兴安岭",
        "0456": "黑龙江 黑河",
        "0468": "黑龙江 鹤岗",
        "0467": "黑龙江 鸡西",
        "0453": "黑龙江 牡丹江",
        "0464": "黑龙江 七台河",
        "0455": "黑龙江 绥化",
        "0469": "黑龙江 双鸭山",
        "0458": "黑龙江 伊春",
        "0512": "江苏 苏州",
        "0519": "江苏 常州",
        "0518": "江苏 连云港",
        "0523": "江苏 泰州",
        "0510": "江苏 无锡",
        "0516": "江苏 徐州",
        "0514": "江苏 扬州",
        "0511": "江苏 镇江",
        "0517": "江苏 淮安",
        "0513": "江苏 南通",
        "0527": "江苏 宿迁",
        "0515": "江苏 盐城",
        "0571": "浙江 杭州",
        "0574": "浙江 宁波",
        "0573": "浙江 嘉兴",
        "0575": "浙江 绍兴",
        "0577": "浙江 温州",
        "0580": "浙江 舟山",
        "0572": "浙江 湖州",
        "0579": "浙江 金华",
        "0578": "浙江 丽水",
        "0576": "浙江 台州",
        "0551": "安徽 合肥",
        "0553": "安徽 芜湖",
        "0556": "安徽 安庆",
        "0552": "安徽 蚌埠",
        "0558": "安徽 阜阳/亳州",
        "0565": "安徽 巢湖",
        "0566": "安徽 池州",
        "0550": "安徽 滁州",
        "0559": "安徽 黄山",
        "0561": "安徽 淮北",
        "0554": "安徽 淮南",
        "0564": "安徽 六安",
        "0555": "安徽 马鞍山",
        "0557": "安徽 宿州",
        "0562": "安徽 铜陵",
        "0563": "安徽 宣城",
        "0591": "福建 福州",
        "0592": "福建 厦门",
        "0595": "福建 泉州",
        "0597": "福建 龙岩",
        "0593": "福建 宁德",
        "0599": "福建 南平",
        "0594": "福建 莆田",
        "0598": "福建 三明",
        "0596": "福建 漳州",
        "0791": "江西 南昌",
        "0797": "江西 赣州",
        "0792": "江西 九江",
        "0798": "江西 景德镇",
        "0796": "江西 吉安",
        "0799": "江西 萍乡",
        "0793": "江西 上饶",
        "0790": "江西 新余",
        "0795": "江西 宜春",
        "0701": "江西 鹰潭",
        "0531": "山东 济南",
        "0532": "山东 青岛",
        "0631": "山东 威海",
        "0535": "山东 烟台",
        "0536": "山东 潍坊",
        "0538": "山东 泰安",
        "0543": "山东 滨州",
        "0534": "山东 德州",
        "0546": "山东 东营",
        "0530": "山东 菏泽",
        "0537": "山东 济宁",
        "0635": "山东 聊城",
        "0539": "山东 临沂",
        "0634": "山东 莱芜",
        "0633": "山东 日照",
        "0533": "山东 淄博",
        "0632": "山东 枣庄",
        "0755": "广东 深圳",
        "0756": "广东 珠海",
        "0769": "广东 东莞",
        "0757": "广东 佛山",
        "0752": "广东 惠州",
        "0750": "广东 江门",
        "0760": "广东 中山",
        "0754": "广东 汕头",
        "0759": "广东 湛江",
        "0768": "广东 潮州",
        "0762": "广东 河源",
        "0663": "广东 揭阳",
        "0668": "广东 茂名",
        "0753": "广东 梅州",
        "0763": "广东 清远",
        "0751": "广东 韶关",
        "0660": "广东 汕尾",
        "0662": "广东 阳江",
        "0766": "广东 云浮",
        "0758": "广东 肇庆",
        "0898": "海南 三亚/海口/陵水黎族自治县",
        "0771": "广西 南宁/崇左",
        "0779": "广西 北海",
        "0770": "广西 防城港",
        "0773": "广西 桂林",
        "0775": "广西 玉林/贵港",
        "0778": "广西 河池",
        "0774": "广西 贺州/梧州",
        "0772": "广西 柳州/来宾",
        "0777": "广西 钦州",
        "0371": "河南 郑州",
        "0379": "河南 洛阳",
        "0378": "河南 开封",
        "0374": "河南 许昌",
        "0372": "河南 安阳",
        "0375": "河南 平顶山",
        "0392": "河南 鹤壁",
        "0391": "河南 焦作/济源",
        "0395": "河南 漯河",
        "0377": "河南 南阳",
        "0393": "河南 濮阳",
        "0398": "河南 三门峡",
        "0370": "河南 商丘",
        "0373": "河南 新乡",
        "0376": "河南 信阳",
        "0396": "河南 驻马店",
        "0394": "河南 周口",
        "0710": "湖北 襄樊",
        "0719": "湖北 十堰/神农架林区",
        "0714": "湖北 黄石",
        "0711": "湖北 鄂州",
        "0718": "湖北 恩施",
        "0713": "湖北 黄冈",
        "0716": "湖北 荆州",
        "0724": "湖北 荆门",
        "0722": "湖北 随州",
        "0717": "湖北 宜昌",
        "0728": "湖北 仙桃/天门/潜江",
        "0712": "湖北 孝感",
        "0715": "湖北 咸宁",
        "0731": "湖南 长沙",
        "0730": "湖南 岳阳",
        "0732": "湖南 湘潭",
        "0736": "湖南 常德",
        "0735": "湖南 郴州",
        "0743": "湖南 凤凰",
        "0734": "湖南 衡阳",
        "0745": "湖南 怀化",
        "0738": "湖南 娄底",
        "0739": "湖南 邵阳",
        "0737": "湖南 益阳",
        "0746": "湖南 永州",
        "0733": "湖南 株洲",
        "0744": "湖南 张家界",
        "0816": "四川 绵阳",
        "0832": "四川 内江/资阳",
        "0827": "四川 巴中",
        "0838": "四川 德阳",
        "0818": "四川 达州",
        "0826": "四川 广安",
        "0839": "四川 广元",
        "0833": "四川 眉山/乐山",
        "0830": "四川 泸州",
        "0817": "四川 南充",
        "0812": "四川 攀枝花",
        "0825": "四川 遂宁",
        "0831": "四川 宜宾",
        "0835": "四川 雅安",
        "0813": "四川 自贡",
        "0851": "贵州 贵阳",
        "0853": "贵州 安顺",
        "0857": "贵州 毕节",
        "0856": "贵州 铜仁",
        "0852": "贵州 遵义",
        "0871": "云南 昆明",
        "0877": "云南 玉溪",
        "0878": "云南 楚雄",
        "0872": "云南 大理",
        "0873": "云南 红河",
        "0874": "云南 曲靖",
        "0691": "云南 西双版纳",
        "0870": "云南 昭通",
        "0891": "西藏 拉萨",
        "0892": "西藏 日喀则",
        "0983": "西藏 山南",
        "0915": "陕西 安康",
        "0917": "陕西 宝鸡",
        "0916": "陕西 汉中",
        "0914": "陕西 商洛",
        "0919": "陕西 铜川",
        "0913": "陕西 渭南",
        "0910": "陕西 咸阳",
        "0911": "陕西 延安",
        "0912": "陕西 榆林",
        "0931": "甘肃 兰州",
        "0943": "甘肃 白银",
        "0932": "甘肃 定西",
        "0935": "甘肃 武威/金昌",
        "0937": "甘肃 酒泉/嘉峪关",
        "0939": "甘肃 陇南",
        "0930": "甘肃 庆阳/临夏",
        "0933": "甘肃 平凉",
        "0938": "甘肃 天水",
        "0936": "甘肃 张掖",
        "0971": "青海 西宁",
        "0972": "青海 海东",
        "0970": "青海 海北",
        "0974": "青海 海南",
        "0951": "宁夏 银川",
        "0952": "宁夏 石嘴山",
        "0953": "宁夏 吴忠/中卫",
        "0991": "新疆 乌鲁木齐",
        "0901": "新疆 塔城",
        "0902": "新疆 哈密",
        "0903": "新疆 和田",
        "0906": "新疆 阿勒泰",
        "0908": "新疆 阿图什",
        "0909": "新疆 博乐",
        "0990": "新疆 克拉玛依",
        "0992": "新疆 奎屯",
        "0993": "新疆 石河子",
        "0994": "新疆 昌吉",
        "0995": "新疆 吐鲁番",
        "0996": "新疆 库尔勒",
        "0997": "新疆 阿克苏",
        "0998": "新疆 喀什",
        "0999": "新疆 伊宁",
        "0888": "云南 丽江",
        "0837": "四川 阿坝藏族羌族自治州",
        "0834": "四川 凉山彝族自治州",
        "0887": "云南 迪庆藏族自治州",
        "0875": "云南 保山",
        "0570": "浙江 衢州",
        "0836": "四川 甘孜藏族自治州",
        "0876": "云南 文山壮族苗族自治州",
        "0692": "云南 德宏傣族景颇族自治州",
        "1853": "澳门",
        "1852": "香港",
        "1886": "台湾"
    };

    return function (key) {
        if(areaCode3[key.slice(0,3)]){
            return areaCode3[key.slice(0,3)];
        }else {
            return areaCode4[key.slice(0,4)] ? areaCode4[key.slice(0,4)] : "区号不存在"
        }
    }
});


define('RobotAgent',["knockout", "require", "wa_Log", "wa_Counter"], function (ko, require, Log, Counter) {
    function robotAgent(robotId,state){
        var recordTime;
        var self=this;
        this.robotId=robotId;
        this.robotNum;
        this.state=state;
        this.callDuration=0;
        this.getCallTime=function(){
            if(this.state == "talk"){
                recordTime=setInterval(function() {
                    //Counter.getTimeFormat(self.callDuration);
                    self.callDuration++;
                }, 1000);
            }
        }
        this.clearCallTime = function(){
            clearInterval(recordTime);
            self.callDuration=0;
        }
    }
    return robotAgent;
});
/**
 * 工具类
 */
define('Utils',[], function () {
    "use strict";
    
    function formatSkillInfo(data) {
        let skillList = data.split(';');
        let arr = [];
        skillList.forEach(function (item, index) {
            if (index !== skillList.length - 1) {
                let itemArr = item.split('=');
                arr.push({
                    value: item,
                    skillName: itemArr[0],
                    checked: true
                });
            }
        });
        return arr;
    }
    
    
    return {
        formatSkillInfo: formatSkillInfo
    };
});

/**
 * Created by fei on 2015/12/8.
 */
define('wa_HandleEvent',["require", "wa_Constant", "wa_Counter", "wa_Tip", "wa_Log", "wa_Vm", "wa_RegisterHandler", "wa_Storage", "area_code", "RobotAgent","Utils"], function (require, constant, counter, tip, Log, vm, registerHandler, storage, areaCode, RobotAgent,utils) {
    "use strict";
    
    var states = constant.states;
    var events = constant.events;
    var setBusySuccessCallback = null;
    var getCallDataCallback = null;
    
    /**
     * 处理事件
     * @param data
     */
    function handleEvent(data) {
        Log.log("receive event: " + JSON.stringify(data));
        vm.doingState(null);    // 收到事件后清除正在状态
        var eventType = data.type;
        if (eventType === events.EVENT_AGENT_LOGIN) {
            //Log.log("登录成功");
            vm.alreadyLogin(true);
            vm.handlerLogout(false);
            vm.isMute(false);
            require('HRCookie').setCookie('sid', vm.sid, 365);
            //外显号
            var outBoundStr = data.ext.outBoundNumList;
            /* outBoundStr="059126487555|059126487555|01026487222|071926498999|043126480777|039426486666|039426486666";*/
            vm.outNumbers([]);
            if (outBoundStr) {
                var outNumbersArr = outBoundStr.split("|");
                var tmpOutNumber = [];
                for (var i = 0; i < outNumbersArr.length; i++) {
                    // console.log(areaCode(outNumbersArr[i]));
                    if (tmpOutNumber.indexOf(outNumbersArr[i]) == -1) {
                        tmpOutNumber.push(outNumbersArr[i]);
                        vm.outNumbers.push({
                            "number": outNumbersArr[i],
                            "area": areaCode(outNumbersArr[i])
                        });
                    }
                    // vm.outNumbers.push(outNumbersArr[i] + " " +areaCode(outNumbersArr[i]));
                }
                vm.outNumbersTmp(vm.outNumbers().slice());
                vm.disNumber(vm.outNumbers()[0].number + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;" + vm.outNumbers()[0].area);
                vm.disNumberWa(vm.outNumbers()[0].number + vm.outNumbers()[0].area);
            }
            
            //小休子状态
            //TODO
            var awayStatusStr = data.ext.awayStatusList;
            //var awayStatusStr = "你好=0;喝水=1;吃饭=2;睡觉=3;开会=4;休息=5";
            vm.awayStatusList([]);
            if (awayStatusStr) {
                var len = awayStatusStr.length;
                var awayStatusArr = [];
                if (awayStatusStr.substr(len - 1, 1) == ";") {
                    awayStatusArr = (awayStatusStr.substring(0, len - 1)).split(";");
                } else {
                    awayStatusArr = awayStatusStr.split(";");
                }
                //var awayStatusArr = awayStatusStr.split(";");
                
                for (var j = 0; j < awayStatusArr.length; j++) {
                    var awayStatu = awayStatusArr[j].split("=");
                    vm.awayStatusList.push({ statuName: awayStatu[0], statuValue: awayStatu[1] });
                }
            }
            
            //IVR协助节点
            var ivrAssistStr = data.ext.ivrAssist;
            vm.ivrAssists([]);
            if (ivrAssistStr) {
                var ivrAssistArr = ivrAssistStr.split(',');
                var ivrAssistObj = {};
                for (var j = 0; j < ivrAssistArr.length; j++) {
                    var ivrNode = ivrAssistArr[j].split('|');
                    ivrAssistObj[ivrNode[0]] = ivrNode[1];
                }
                
                for (var key in ivrAssistObj) {
                    vm.ivrAssists.push({
                        key: key,
                        value: ivrAssistObj[key]
                    });
                }
            }
            
            //IVR回转节点
            var ivrRouterStr = data.ext.ivrTransfer;
            vm.ivrRouters([]);
            if (ivrRouterStr) {
                var ivrRouterArr = ivrRouterStr.split(',');
                var ivrRouterObj = {};
                for (var j = 0; j < ivrRouterArr.length; j++) {
                    var ivrNode = ivrRouterArr[j].split('|');
                    ivrRouterObj[ivrNode[0]] = ivrNode[1];
                }
                
                for (var key in ivrRouterObj) {
                    vm.ivrRouters.push({
                        key: key,
                        value: ivrRouterObj[key]
                    });
                }
            }
            
            // 技能组 WebAgent.skillInfo
            if(data.ext.skillInfo){
                WebAgent.userMessage.skillList = utils.formatSkillInfo(data.ext.skillInfo);
                WebAgent.userMessage.factSkillInfo = utils.formatSkillInfo(data.ext.factSkillInfo);
            }
            
            WebAgent.userMessage.agentName = data.ext.agentName;
            WebAgent.userMessage.nubeNum = data.ext.nubeNum;
    
            vm.agentRole(data.ext.agentType || "1");
            
            vm.loginMessage(null);
            
            // TODO 是否在登录成功的事件里做判断
            //如果勾选记住登录信息，则在localStorage中存储登录信息，否则清除
            vm.rememberLogin() ? storage.saveLoginInfo() : storage.clearLoginInfo();
            
        } else if (eventType === events.EVENT_NETTY_LOGIN_SUCCESS) {
            Log.log("Netty方式登录成功(已有Http方式登录)");
            vm.alreadyLogin(true);
            
            // 取出最近保存的事件，手动执行事件回调恢复状态
            var recentEvent = data.ext.currentEvent;
            handleEvent({
                type: recentEvent, ext: {}
            });
            
        } else if (eventType === events.EVENT_AGENT_LOGOUT) {
            var forceLogout = data.ext && data.ext.forceLogout == '1';
            var needLogin = data.ext && data.ext.needLogin == '1';
            Log.log("登出成功 - " + (forceLogout ? "异常登出" : "正常登出"));
            vm.alreadyLogin(false);
            vm.currentState(states.INIT);
            vm.operBoxDisplay(false);
            if (forceLogout || needLogin) {
                vm.loginMessage("您已被强制登出（可能在另一点登录或者服务异常）");
                WebAgent.isNormalError = true;
                vm.handlerLogout(true);
                //sip分机使用cphone或者butel分机时登出cphone
                if (vm.sipUseCphone() && vm.agentNumber && vm.agentNumber().indexOf("sip:") == 0) {
                    WebAgent.ButelAjax && WebAgent.ButelAjax.ajaxFunc("Logout", "logout", "");
                }
                if (window.CR) {
                    window.CR.logout();
                }
                //登出chat
                WebAgent.ChatLogout();
                // 登出后断开并重连socket，刷新会话，避免复杂问题
                require("wa_Socket").reconnectSocket();
                if(needLogin){
                    let t = setTimeout(function () {
                        let isSocketConnect = require("wa_Socket").isSocketConnect();
                        if(isSocketConnect){
                            WebAgent.multiChannelLogin(WebAgent, {
                                entId        : WebAgent.vm.entId(),
                                agentId      : WebAgent.vm.agentId(),
                                agentPassword: WebAgent.vm.agentPassword(),
                                agentNumber  : WebAgent.vm.agentNumber(),
                                waAutoLoginResult: false,
                            });
                            clearTimeout(t);
                            WebAgent.isConnect = true;
                        }
                    },5000)
                }
            }else{
                // 登出后断开并重连socket，刷新会话，避免复杂问题
                require("wa_Socket").reconnectSocket();
                WebAgent.isConnect = false;
            }
        } else if (eventType === events.EVENT_AGENT_LOGIN_FAIL) {
            Log.log("登录失败");
            if (data.ext && data.ext.errorMessage) {
                vm.loginMessage(data.ext.errorMessage);
            }
        } else if (eventType === events.EVENT_AGENT_READY) {
            Log.log("置闲成功");
            vm.currentState(states.READY);
            counter.stop().clear();     // 置闲 - 清空计时
        } else if (eventType === events.EVENT_AGENT_NOTREADY) {
            Log.log("置忙成功");
            vm.currentState(states.BUSY);
            counter.stop().clear();      // 置忙 - 清空计时
            setBusySuccessCallback && setBusySuccessCallback();
            setBusySuccessCallback = null;
        }else if (eventType === events.EVENT_AGENT_WORKSTATE) {
            Log.log("工作状态成功");
            vm.currentState(states.WORKING);
            counter.stop().clear();      // 置忙 - 清空计时
        } else if (eventType === events.EVENT_AGENT_AWAY) {
            Log.log("小休成功");
            vm.currentState(states.AWAY);
            counter.stop().clear();      // 置忙 - 清空计时
        } else if (eventType === events.EVENT_SET_AWAY_FAIL) {
            Log.log("小休失败");
            //vm.currentState(states.AWAY);
            //counter.stop().clear();      // 置忙 - 清空计时
        } else if (eventType === events.EVENT_OUTBOUND_ALERTING_TP) {
            Log.log("外呼坐席振铃");
            vm.currentState(states.AGENT_ALERTING);
        } else if (eventType === events.EVENT_OUTBOUND_CONNECTED_TP) {
            Log.log("外呼坐席接通");
            vm.currentState(states.AGENT_CONNECTED);
        } else if (eventType === events.EVENT_OUTBOUND_ALERTING_OP) {
            Log.log("外呼客户振铃");
            vm.currentState(states.CUSTOM_ALERTING);
        } else if (eventType === events.EVENT_OUTBOUND_CONNECTED_OP) {
            Log.log("外呼客户接通，双方通话");
            if (WebAgent.licenseCustomer != "1") {
                window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
                //传递技能组id(为视频推送提供服务)
                if (window.vm.callInUser() && window.vm.callInUser().isCalling) {
                    data.ext.chatType = window.vm.callInUser().chatType();
                    data.ext.skillName = window.vm.callInUser().skillName;
                } else if (window.vm.currentUser() && window.vm.currentUser().isCalling) {
                    data.ext.skillName = window.vm.currentUser().skillName;
                    data.ext.chatType = window.vm.currentUser().chatType();
                }
            }
            vm.currentState(states.CONNECTED);
            counter.start();    // 双方通话 - 开始计时
        } else if (eventType === events.EVENT_TP_DISCONNECT || eventType === events.EVENT_OP_DISCONNECT) {
            Log.log(eventType === events.EVENT_TP_DISCONNECT ? "坐席挂断" : "客户挂断");
            vm.operBoxDisplay(false);
            vm.isMute(false);
            WebAgent.licenseCustomer != "1" && window.vm.callEnd(data.ext.strDnis);
            require("dialog").hide(); //如果dialog在的话，隐藏
        } else if (eventType === events.EVENT_AGENT_HOLD) {
            Log.log("坐席保持");
            vm.currentState(states.HOLD);
        } else if (eventType === events.EVENT_HOLD_RETRIEVE) {
            Log.log("坐席保持接回，变为双方通话");
            vm.currentState(states.CONNECTED);
        } else if (eventType === events.EVENT_CONSULT_ALTERTING_OP) {
            Log.log("咨询振铃");
            vm.currentState(states.CONSULT_ALERTING);
        } else if (eventType === events.EVENT_CONSULT_CONNECTED_OP) {
            Log.log("咨询接通");
            vm.currentState(states.CONSULTED);
        } else if (eventType === events.EVENT_CONSULT_RETRIEVE) {
            Log.log("咨询接回，变为双方通话");
            vm.currentState(states.CONNECTED);
        } else if (eventType === events.EVENT_TRANSFER) {
            Log.log("转移事件，变为双方通话");
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            vm.currentState(states.CONNECTED);
        } else if (eventType === events.EVENT_CONSULT_ALERTING_TP) {
            Log.log("被咨询振铃");
            vm.currentState(states.CONSULT_B_ALERTING);
        } else if (eventType === events.EVENT_CONSULT_CONNECTED_TP) {
            Log.log("被咨询接通");
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            counter.start();
            vm.currentState(states.CONSULTED_B);
        } else if (eventType === events.EVENT_MONITOR_ALERTING) {
            Log.log("监听振铃");
            vm.currentState(states.OBSERVE_ALERTING);
        } else if (eventType === events.EVENT_MONITOR) {
            Log.log("监听接通");
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            vm.currentState(states.OBSERVED);
            counter.stop().clear();
        } else if (eventType === events.EVENT_INBOUND_ALERTING) {
            Log.log("呼入坐席振铃");
            vm.currentState(states.AGENT_ALERTING);
        } else if (eventType === events.EVENT_INBOUND_CONNECTED) {
            Log.log("呼入坐席接通，变为双方通话");
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            vm.currentState(states.CONNECTED);
            vm.callNumber(data.ext.strAni);
            counter.start();    // 双方通话 - 开始计时
        } else if (eventType === events.EVENT_FORCE_CONNECT) {
            Log.log("强插成功，变为会议状态");
            vm.currentState(states.CONFERENCED);
        } else if (eventType === events.EVENT_FORCE_DROP_SUCCESS) {
            vm.operBoxDisplay(false);
            WebAgent.licenseCustomer != "1" && window.vm.callEnd();
            Log.log("强拆事件");
        } else if (eventType === events.EVENT_CLEAR_CALL) {
            vm.operBoxDisplay(false);
            WebAgent.licenseCustomer != "1" && window.vm.callEnd();
            Log.log("全拆事件");
        } else if (eventType === events.EVENT_CONFERENCE) {
            if (data.ext.conferenceMembers == 4) {
                Log.log("四方会议本方接通事件");
                vm.meetingNum(data.ext.conferenceMembers);
                counter.start();
                vm.currentState(states.MP_CONFERENCE);
            } else {
                Log.log("会议事件");
                vm.currentState(states.CONFERENCED);
            }
        } else if (eventType === events.EVENT_QUIT_MONITOR_SUCCESS) {
            WebAgent.licenseCustomer != "1" && window.vm.callEnd();
            Log.log("监听退出/强插退出");
            vm.isMute(false);
        } else if (eventType === events.EVENT_INTERNAL_ALERTING_TP) {
            Log.log("发起方内呼振铃");
            vm.currentState(states.INTERNAL_ALERTING);
        } else if (eventType === events.EVENT_INTERNAL_ALERTING_OP) {
            Log.log("被内呼方振铃");
            // vm.currentState(states.INTERNAL_ALERTING);
        } else if (eventType === events.EVENT_INTERNAL_CONNECTED_TP) {
            Log.log("发起方内呼接通");
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            vm.currentState(states.INTERNAL_CONNECTED);
            counter.start();    // 内呼接通 - 开始计时
        } else if (eventType === events.EVENT_INTERNAL_CONNECTED_OP) {
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            Log.log("被内呼方内呼接通");
            vm.currentState(states.INTERNAL_CONNECTED);
            counter.start();    // 内呼接通 - 开始计时
        } else if (eventType === events.EVENT_AGENT_ACW) {
            Log.log("事后整理");
            vm.currentState(states.ACW);
            counter.stop();     // 事后整理 - 停止计时
        } else if (eventType === events.EVENT_SINGLE_STEP_TRANSFER_CONNECTED_TP) {
            WebAgent.licenseCustomer != "1" && window.vm.sendState("msgFromAgentCallStart", "msgFromAgentCallStart", "PC");
            Log.log("单步转移接通，变为双方通话");
            counter.start();    // 内呼接通 - 开始计时
            vm.currentState(states.CONNECTED);
        } else if (eventType === events.EVENT_SINGLE_STEP_TRANSFER_ALERTING_TP) {
            Log.log("单步转移振铃");
            vm.currentState(states.TRANSFER_ALERTING);
        } else if (eventType === events.EVENT_CALL_CONTROL_FAIL) {
            Log.log("话路控制失败");
            tip("话路控制失败: " + data.ext.errorMessage);
            
            //话路控制失败，恢复原来的状态，内呼失败用到
            if (vm.currentState() == constant.states.CONNECTING) {
                vm.currentState(states.BUSY);
            }
        } else if (eventType === events.EVENT_CONSULT_FAIL) {
            Log.log("咨询失败");
            tip("咨询失败: " + data.ext.errorMessage);
        } else if (eventType === events.EVENT_MONITOR_FAIL) {
            Log.log("监听失败");
            tip("监听失败: " + data.ext.errorMessage);
        } else if (eventType === events.EVENT_INTRUDE_FAIL) {
            Log.log("强插失败");
            tip("强插失败: " + data.ext.errorMessage);
        } else if (eventType === events.EVENT_FORCE_DROP_FAIL) {
            Log.log("强拆失败");
            tip("强拆失败: " + data.ext.errorMessage);
        } else if (eventType === events.EVENT_AGENT_BEHOLD) {
            Log.log("坐席被保持");
            vm.currentState(states.BEHOLD);
        } else if (eventType === events.EVENT_AGENT_BEUNHOLD) {
            Log.log("坐席被保持接回，变为双方通话");
            vm.currentState(states.CONNECTED);
            
            //使用面板时，ivr协助后获取随路数据
            if (vm.ui()) {
                //ivr协助返回的保持接回异步事件,获取随路数据
                var result = require("wa_Extend").getCallData("QNIVRRESULT", function (value) {
                    switch ( value ) {
                        case "0":
                            vm.ivrConfirmDialogResult("fail");
                            break;
                        case "1":
                            vm.ivrConfirmDialogResult("success");
                            break;
                        case "2": {
                            vm.ivrConfirmDialogResult("timeout");
                            break;
                        }
                        case "3": {
                            vm.ivrConfirmDialogResult("error");
                            break;
                        }
                        default :
                            break;
                    }
                });
                
                if (result.code === 0) {
                    Log.log("ivr协助，获取随路数据命令发送成功");
                } else {
                    Log.warn(result.msg);
                }
            }
            
        } else if (eventType === events.EVENT_GET_ASSOCIATE_DATA) {
            Log.log("获得随路数据返回事件");
            var callData = data.ext.result;
            getCallDataCallback && getCallDataCallback(callData);
            getCallDataCallback = null;
        } else if (eventType === events.EVENT_SET_ASSOCIATE_DATA) {
            Log.log("设置随路数据返回事件");
        } else if (eventType == events.EVENT_AGENT_GET_LIST) {
            vm.agentList([]);
            vm.workingAgentList([]);
            var agentListStr = data.ext.agentList;
            var agentListArr = agentListStr.split("|");
            var agentItem;
            for (var i = 0; i < agentListArr.length - 1; i++) {
                agentItem = agentListArr[i].split(":");
                vm.agentList.push({
                    agentName: agentItem[2],
                    agentId: agentItem[0]
                });
            }
            if(!vm.isGetWorkingAgent()){
                vm.skillList([]);
                //新增转接技能组,事件返回技能组列表
                //vm.skillList(data.ext.skillList.split("|") || []);
                var skillNameStr = data.ext.skillList;
                var skillNameArr = skillNameStr.split("|");
                for (var index in skillNameArr) {
                    vm.skillList.push({
                        skillName: skillNameArr[index]
                    });
                }
            }
            
        } else if (eventType === events.EVENT_AGENT_LOGIN_FAIL_ROBOT || eventType === events.EVENT_AGENT_NOTREADY_ROBOT || eventType === events.EVENT_AGENT_READY_ROBOT || eventType === events.EVENT_INBOUND_CONNECTED_ROBOT) {
            var agentRobot = isInRobotAgentList(data.agentId);
            var stateObj = {
                "EVENT_AGENT_LOGIN_FAIL_ROBOT": "logout",
                "EVENT_AGENT_NOTREADY_ROBOT": "busy",
                "EVENT_AGENT_READY_ROBOT": "ready",
                "EVENT_INBOUND_CONNECTED_ROBOT": "talk"
            };
            if (agentRobot) {
                agentRobot.state = stateObj[data.type];
            } else {
                vm.robotAgentList.push(new RobotAgent(data.agentId, stateObj[data.type]));
            }
        } else if (eventType === events.EVENT_MP_CONFERENCE_ALERTING_TP) {
            Log.log("多方会议本方振铃事件");
            vm.meetingNum(data.ext.conferenceMembers);
            vm.currentState(states.MP_CONFERENCE_ALERTING_TP);
        } else if (eventType === events.EVENT_MP_CONFERENCE_ALERTING_OP) {
            Log.log("多方会议对方振铃事件");
            vm.meetingNum(data.ext.conferenceMembers);
            vm.currentState(states.MP_CONFERENCE_ALERTING_OP);
        } else if (eventType === events.EVENT_MP_CONFERENCE_CONNECTED_TP) {
            Log.log("多方会议本方接通事件");
            vm.meetingNum(data.ext.conferenceMembers);
            counter.start();    // 内呼接通 - 开始计时
            vm.currentState(states.MP_CONFERENCE);
        } else if (eventType === events.EVENT_MP_CONFERENCE_CONNECTED_OP) {
            Log.log("多方会议对方接通事件");
            vm.meetingNum(data.ext.conferenceMembers);
            vm.currentState(states.MP_CONFERENCE);
        } else if (eventType === events.EVENT_MP_CONFERENCE_DISCONNECT_TP) {
            Log.log("多方会议本方挂断事件");
            vm.meetingNum(data.ext.conferenceMembers);
        } else if (eventType === events.EVENT_MP_CONFERENCE_DISCONNECT_OP) {
            Log.log("多方会议对方挂断事件");
            vm.currentState(states.CONFERENCED);
            vm.meetingNum(data.ext.conferenceMembers);
        } else if (eventType === events.EVENT_JOIN_CONFERENCE_FAIL) {
            Log.log("加入会议失败事件");
            vm.meetingNum(data.ext.conferenceMembers);
        } else if (eventType === events.EVENT_STARTCRYPTO) {
            Log.log("发起方:开启密语成功事件");
            counter.start();    // 内呼接通 - 开始计时
            vm.currentState(states.LAUNCH_CRYPTOLALIA);
        } else if (eventType === events.EVENT_BE_STARTCRYPTO) {
            Log.log("接收方:开启密语成功事件");
            vm.currentState(states.CRYPTOLALIA);
        } else if (eventType === events.EVENT_STARTCRYPTO_FAIL) {
            Log.log("开启密语失败事件");
        } else if (eventType === events.EVENT_STOPCRYPTO) {
            Log.log("关闭密语成功事件");
            vm.currentState(states.CONNECTED);
        } else if (eventType === events.EVENT_STOPCRYPTO_FAIL) {
            Log.log("关闭密语失败事件");
        } else if (eventType === events.EVENT_INTERCEPT_FAIL) {
            Log.log("拦截失败事件");
        } else if (eventType === events.EVENT_SINGLE_STEP_CONFERENCE_ALERTING_OP) {
            Log.log("单步会议对方振铃事件");
            vm.currentState(states.SINGLE_STEP_CONFERENCE_ALERTING);
        } else if (eventType === events.EVENT_SINGLE_STEP_CONFERENCE_ALERTING_TP) {
            Log.log("单步会议本方振铃事件");
            vm.currentState(states.SINGLE_STEP_CONFERENCE_ALERTING);
        } else if (eventType === events.EVENT_SINGLE_STEP_CONFERENCE_CONNECTED_OP) {
            Log.log("单步会议对方接通");
        } else if (eventType === events.EVENT_SINGLE_STEP_CONFERENCE_CONNECTED_TP) {
            Log.log("单步会议本方接通");
            counter.start();
        } else if (eventType === events.EVENT_SWTCH_SKILLGROUP_SUCCESS) {
            Log.log("技能组切换成功");
            if(data.ext.factSkillInfo){
                WebAgent.userMessage.factSkillInfo = utils.formatSkillInfo(data.ext.factSkillInfo);
            }
        } else if (eventType === events.EVENT_SWTCH_SKILLGROUP_FAIL) {
            Log.log("技能组切换失败");
        }
        
        // 执行自定义事件处理函数
        registerHandler.triggerEvent(data);
    }
    
    function isInRobotAgentList(robotId) {
        return vm.robotAgentList().find(function (item) {
            return item.robotId == robotId;
        });
    }
    
    return {
        setBusySuccessCallback: function (callback) {
            setBusySuccessCallback = callback;
        },
        setGetCallDataCallback: function (callback) {
            getCallDataCallback = callback;
        },
        handleEvent: handleEvent
    };
});

/**
 * Created by fei on 2015/12/4.
 */

define('wa_CheckInit',["wa_Constant", "wa_Vm", "wa_Storage", "wa_RegisterHandler"],function(constant, vm, storage, registerHandler) {
    "use strict";

    /**
     * 自动登录是否完成(不论成功或失败)
     * (当收到autoLogin的result时修改为true)
     * @type {boolean}
     */
    var autoLoginFinished = false;

    /**
     * 自动登录是否成功
     * @type {boolean}
     */
    var autoLoginResult = false;

    /**
     * UI元素是否初始化成功
     * (当ko,css,dom,bindings等都完成时修改为true)
     * @type {boolean}
     */
    var initUISuccess = false;

    /**
     * 调用WA.init()传入的回调函数
     * 当initUISuccess和autoLoginFinished都为true时触发
     * @type {null}
     */
    var initSuccessCallback = null;

    /**
     * 自动登录返回的数据
     *
     */
    var autoLoginData = null;

    function checkInitSuccess() {

        if (initUISuccess && autoLoginFinished) {

            // 在自动登录未成功时，从localStorage中恢复登录信息
            if (!autoLoginResult) {
                storage.resumeLoginInfo();
            }

            if (typeof initSuccessCallback === "function") {
                setTimeout(function() {
                    initSuccessCallback(autoLoginResult,autoLoginData);
                    if(autoLoginData.type === constant.commands.AUTO_LOGIN) {
                        registerHandler.triggerResult(autoLoginData);
                    }
                    initSuccessCallback = null;
                }, 300);
            }
        }
    }

    return {
        setAutoLoginFinish: function() {
            autoLoginFinished = true;
            return this;
        },
        autoLoginResult: function(value) {
            autoLoginResult = value;
        },
        autoLoginData: function(value) {
            autoLoginData = value;
        },
        setInitUISuccess: function() {
            initUISuccess = true;
            return this;
        },
        initSuccessCallback: function(value) {
            initSuccessCallback = value;
        },
        checkInitSuccess: checkInitSuccess
    }
});
/**
 * Created by fei on 2015/12/8.
 */
define('wa_HandleCommandResult',["wa_Constant","wa_Tip", "wa_Log", "wa_Vm", "wa_RegisterHandler", "wa_CheckInit"],
    function(constant, tip, Log, vm, registerHandler, checkInit) {
    "use strict";

    var states = constant.states;
    var commands = constant.commands;
    /**
     * 处理控制同步返回结果
     * @param data
     */
    return function (data) {
        Log.log("receive result: " + JSON.stringify(data));
        var resultType = data.type;
        var code = data.code;
        var msg = data.msg;
        if (resultType === commands.AUTO_LOGIN) {
            if (code != 0) {
                Log.log("自动登录失败：" + msg);
                if(!WebAgent.disconnectError){
                    checkInit.autoLoginResult(false);
                    checkInit.autoLoginData(data);
                }else {
                    registerHandler.triggerResult(data);
                }
            } else {
                Log.log("自动登录成功");
                checkInit.autoLoginResult(true);
                checkInit.autoLoginData(data);
                vm.handlerLogout(false);
                var map = data.ext;
                vm.entId(map.entId);
                vm.agentId(map.agentId);
                vm.agentPassword(map.agentPwd);
                //vm.agentNumber(map.agentDn);
                //使用butel分机时，自动登录成功设置agentNumber为空，否则登出后再登录会提示“分机号码不存在”，导致登录失败
                vm.agentNumber(map.agentDn.indexOf('btl:') == 0 ? '': map.agentDn);
                vm.agentRole(map.agentType);
                vm.alreadyLogin(map.isAlreadyLogin == "true");
                var state = null;
                switch (map.agentStatus) {
                    case "Idle" :
                        state = states.READY;
                        break;
                    case "NotReady" :
                        state = states.BUSY;
                        break;
                    case "Ringing" :
                        state = states.AGENT_ALERTING;
                        break;
                    case "Acw" :
                        state = states.ACW;
                        break;
                    case "Held" :
                        state = states.HOLD;
                        break;
                    case "Talking" :
                        state = states.CONNECTED;
                        break;
                    case "loggedOut" :
                        state = states.LOGOUT;
                        break;
                    case "Dialing" :
                        state = states.CONNECTING;
                        break;
                    case "Away":
                        state = states.AWAY;
                        break;
                    case "WORKING":
                        state = states.WORKING;
                        break;
                }

                vm.currentState(state);

                //外显号
                var outBoundStr = map.outboundList;
                vm.outNumbers([]);
                if (outBoundStr) {
                    var outNumbersArr = outBoundStr.split("|");
                    for(var i = 0; i < outNumbersArr.length; i++) {
                        if(vm.outNumbers().indexOf(outNumbersArr[i]) == -1) {
                            vm.outNumbers.push(outNumbersArr[i]);
                        }
                    }
                }

                //小休子状态
                var awayStatusStr = map.awayStatusList;
                //var awayStatusStr = "你好=0;喝水=1;吃饭=2;睡觉=3;开会=4;休息=5";
                vm.awayStatusList([]);
                if(awayStatusStr) {
                    var len = awayStatusStr.length;
                    var awayStatusArr = [];
                    if(awayStatusStr.substr(len-1,1) == ";") {
                        awayStatusArr = (awayStatusStr.substring(0,len-1)).split(";");
                    } else {
                        awayStatusArr = awayStatusStr.split(";");
                    }
                    //var awayStatusArr = awayStatusStr.split(";");

                    for(var j = 0; j < awayStatusArr.length; j++) {
                        var awayStatu = awayStatusArr[j].split("=");
                        vm.awayStatusList.push({statuName: awayStatu[0], statuValue: awayStatu[1]});
                    }
                }

                //IVR协助节点
                var ivrAssistStr = map.ivrAssist;
                vm.ivrAssists([]);
                if(ivrAssistStr) {
                    var ivrAssistArr = ivrAssistStr.split(',');
                    var ivrAssistObj = {};
                    for(var j = 0; j < ivrAssistArr.length; j++) {
                        var ivrNode = ivrAssistArr[j].split('|');
                        ivrAssistObj[ivrNode[0]] = ivrNode[1];
                    }

                    for(var key in ivrAssistObj) {
                        vm.ivrAssists.push({
                            key: key,
                            value: ivrAssistObj[key]
                        });
                    }
                }

                //IVR回转节点
                var ivrRouterStr = map.ivrTransfer;
                vm.ivrRouters([]);
                if(ivrRouterStr) {
                    var ivrRouterArr = ivrRouterStr.split(',');
                    var ivrRouterObj = {};
                    for(var j = 0; j < ivrRouterArr.length; j++) {
                        var ivrNode = ivrRouterArr[j].split('|');
                        ivrRouterObj[ivrNode[0]] = ivrNode[1];
                    }

                    for(var key in ivrRouterObj) {
                        vm.ivrRouters.push({
                            key: key,
                            value: ivrRouterObj[key]
                        });
                    }
                }
                registerHandler.triggerResult(data);

            }
            checkInit.setAutoLoginFinish().checkInitSuccess();

            } else if (resultType === commands.LOGIN || resultType === commands.FORCE_LOGIN) {
                if (code != 0) {
                    Log.log("登录失败: " + msg);
                    vm.loginMessage(msg);
                    vm.doingState(null);
                    if(WebAgent.isConnect){
                        let t = null;
                        function onConnect() {
                            if(WebAgent.connectNum >= 0){
                                t = setTimeout(function () {
                                    WebAgent.multiChannelLogin(WebAgent, {
                                        entId        : WebAgent.vm.entId(),
                                        agentId      : WebAgent.vm.agentId(),
                                        agentPassword: WebAgent.vm.agentPassword(),
                                        agentNumber  : WebAgent.vm.agentNumber(),
                                        waAutoLoginResult: false,
                                    });
                                    clearTimeout(t);
                                    WebAgent.connectNum --;
                                },5000)
                            }else{
                                WebAgent.isConnect = false;
                                WebAgent.connectNum = 14;
                            }
                        }
                        onConnect();
                    }
                }else{
                    WebAgent.isConnect = false;
                    WebAgent.connectNum = 14;
                }
            registerHandler.triggerResult(data);
            } else {
                if (code != 0) {
                    tip(msg);
                    vm.doingState(null); //发送命令失败清除doingState
                }
                registerHandler.triggerResult(data);
            }

            // 设置"正在xxx"的状态 ("000" == 0 -> true)
            //if (code == 0) {
            //    var stateING = null;
            //    switch (resultType) {
            //        case commands.MAKE_CALL:
            //        case commands.MAKE_CALL_INTERNAL:
            //            stateING = states.CONNECTING;
            //            break;
            //        case commands.CONSULT:
            //            stateING = states.CONSULTING;
            //            break;
            //        case commands.TRANSFER:
            //        case commands.SINGLE_TRANSFER:
            //            stateING = states.TRANSFERRING;
            //            break;
            //        case commands.CONFERENCE:
            //            stateING = states.CONFERENCING;
            //            break;
            //        case commands.OBSERVE:
            //            stateING = states.OBSERVING;
            //            break;
            //        case commands.FORCE_INSERT:
            //            stateING = states.INSERTING;
            //            break;
            //        case commands.FORCE_ABORT:
            //            stateING = states.FORCE_ABORTING;
            //            break;
            //        case commands.FULL_ABORT:
            //            stateING = states.FULL_ABORTING;
            //            break;
            //        default:
            //    }
            //    stateING && vm.doingState(stateING);
            //}

            //registerHandler.triggerResult(data);
        };
    });

define('HRCookie',['jquery'], function($) {
    return {
        setCookie: function(cname,cvalue,exdays){
            var d = new Date();
            d.setTime(d.getTime() + (exdays*24*60*60*1000));
            var expires = "expires=" + d.toGMTString();
            document.cookie = cname + "=" + cvalue + "; " + expires;
        },

        getCookie: function(cname){
            var name = cname + "=";
            var ca = document.cookie.split(";");
            for(var i = 0; i < ca.length; i++){
    
                var c = $.trim(ca[i]);
                if(c.indexOf(name) == 0){
                    return c.substring(name.length, c.length)
                }
            }
            return "";
        }
    }
});
/**
 * Created by fei on 2015/12/3.
 */
define('wa_Socket',["require", "wa_io", "wa_Constant", "wa_Log", "wa_Vm", "wa_HandleEvent", "wa_HandleCommandResult", "wa_RegisterHandler","HRCookie"], function(require, io, constant, Log, vm, handleEvent, handleCommandResult, registerHandler,HRCookie) {
    "use strict";

    var socket;
    var timeout;
    var sid;

    var login = function (data) {
        if(data.type == "autoLogin" && data.code == -1 && !WebAgent.isNormalError){
            //异常情况下自动登入失败，代码执行登入agentProxy
            WebAgent.extend.login({
                entId        : vm.entId(),
                agentId      : vm.agentId(),
                agentPassword: vm.agentPassword(),
                agentNumber  : vm.agentNumber(),
                isForce : true
            });
        }
    };
    var handleConnected = function() {
        Log.info("连接服务器成功");
        if(timeout){
            clearTimeout(timeout);
        }else{
            sid = socket.id;
            WebAgent.vm.sid=sid;
            HRCookie.setCookie('sid', sid, 365);
        }
    };

    var handleDisconnected = function() {
        Log.warn("与服务器断开连接");
        WebAgent.disconnectError=false;
        WebAgent.removeResultHandler(login);

        if(WebAgent.isNormalError || vm.handlerLogout()) {
            if (vm.alreadyLogin()) {        // 区分是主动断开（登出后执行）还是被动断开（登录中服务断开），给予提示
                vm.loginMessage("连接断开");
            }

            vm.alreadyLogin(false);
            vm.currentState(constant.states.INIT);
            //WebAgent.removeResultHandler(login);

            //与服务器断开连接时清除doingState
            vm.doingState(null);
            return;
        }
        WebAgent.registerResultHandler(login);
        WebAgent.disconnectError=true;
        timeout=setTimeout(function () {
            console.log("执行报异常");
            // 执行自定义事件处理函数
            WebAgent.removeResultHandler(login);
            registerHandler.triggerEvent({
                type: constant.events.EVENT_SOCKET_ABNORMAL_DISCONNECT,
                ext: {
                    errorMessage: "socket异常断开"
                }
            });
        },15000);
    };

    var initSocket = function() {
        if (!io) {
            throw new Error("io is undefined, please check your socket.io importing.");
        }
        sid = HRCookie.getCookie('sid');

        //socket = io.connect(WebAgent.host);
        //socket = io(WebAgent.host, { transports: [ 'websocket' ] });
        socket = io(WebAgent.host, {
            path: WebAgent.agentProxyPath,
            transports: [ 'websocket' ],
            query: "lastSessionId=" + sid
        });
       // socket = io(WebAgent.host, { transports: [ 'polling' ] });

        //var judgeIE8 = navigator.userAgent.indexOf("MSIE 8.0");
        //var judgeIE9 = navigator.userAgent.indexOf("MSIE 9.0");
        //
        //if((judgeIE8 > 0) || (judgeIE9 > 0)) {
        //    socket = io.connect(WebAgent.host);
        //} else {
        //    /**
        //     * After some research and tests I found out that when using
        //     * netty-socketio as server, you need to specify the transport method on the client side
        //     */
        //    socket = io(WebAgent.host, { transports: [ 'websocket' ] });
        //}

        socket.on("connect", handleConnected);
        socket.on("disconnect", handleDisconnected);
        socket.on("event", handleEvent.handleEvent);
        socket.on("result", handleCommandResult);

        socket.on("connect_error", function(obj) {
            Log.info("connect_error" + obj);
        });

        socket.on("reconnect_attempt", function() {
            Log.info("reconnect_attemp");
        });

        socket.on("reconnecting", function() {
            //socket断开重连，
            Log.info("reconnecting");

            if(vm.handlerLogout()){
                var t = require("ButelAjax").getT();

                //console.log("setInterval:" + t);

                //清除查询cphone
                 if(t) {
                     clearInterval(t);
                     require("ButelAjax").setT(null);
                 }
            }


            //registerHandler.triggerEvent({
            //    type: constant.events.EVENT_SOCKET_RECONNECTING,
            //    ext: {
            //        errorMessage: "socket正在重连"
            //    }
            //});
        });

        socket.on("reconnect_error", function(obj) {
            Log.info("reconnect_error" + obj);
        });

        socket.on("reconnect_failed", function() {
            Log.info("reconnect_failed");
        });
    };

    /**
     * socket重连
     */
    var reconnectSocket = function() {
        socket.disconnect();
        setTimeout(function () {
            socket.connect();
        }, 500);
    };

    var states = constant.states;
    var commands = constant.commands;

    /**
     * 发送命令
     * @param commandObj
     */
    var sendCommand = function(commandObj) {
        if (socket) {

            //发送命令前赋值doingState
            var stateING = null;
            switch (commandObj.type) {
                case commands.MAKE_CALL:
                case commands.MAKE_CALL_INTERNAL:
                    stateING = states.CONNECTING;
                    break;
                case commands.CONSULT:
                    stateING = states.CONSULTING;
                    break;
                case commands.TRANSFER:
                case commands.SINGLE_TRANSFER:
                    stateING = states.TRANSFERRING;
                    break;
                case commands.CONFERENCE:
                    stateING = states.CONFERENCING;
                    break;
                case commands.OBSERVE:
                    stateING = states.OBSERVING;
                    break;
                case commands.FORCE_INSERT:
                    stateING = states.INSERTING;
                    break;
                case commands.FORCE_ABORT:
                    stateING = states.FORCE_ABORTING;
                    break;
                case commands.FULL_ABORT:
                    stateING = states.FULL_ABORTING;
                    break;
                case commands.JOIN_CONFERENCE:
                    stateING = states.MP_CONFERENCING;
                    break;
                default:
            }
            vm.doingState(stateING);

            Log.log("send command: " + JSON.stringify(commandObj));
            socket.emit("command", commandObj);
        } else {
            Log.error("服务未连接，操作无法进行");
        }
    };

    /**
     * 判断当前socket是否连接到服务器
     */
    var isSocketConnect = function() {
        return socket && socket.connected;
    };

    return {
        initSocket: initSocket,
        sendCommand: sendCommand,
        isSocketConnect: isSocketConnect,
        reconnectSocket: reconnectSocket
    }
});

/**
 * Created by fei on 2015/12/3.
 */
define('wa_Extend',["wa_Log", "wa_Constant", "wa_Vm", "wa_Socket", "wa_HandleEvent"], function(Log, constant, vm, socket, handleEvent) {
    "use strict";

    /**
     * 对外接口
     */
    var extend = {};

    var commands = constant.commands;
    var states = constant.states;

    extend.login = function(params) {
        //if (!vm.loginEnabled()) { return { code : -1, msg : "Login denied" }; }
        if (!socket.isSocketConnect()) { return { code : -1, msg : "服务未连接" }; }

        params = params || {};

        if (!params.entId) { return { code : -2, msg : "企业编号必填" }; }
        if (!params.agentId) { return { code : -2, msg : "坐席工号必填" }; }
        //if (!params.agentNumber) { return { code : -2, msg : "坐席分机必填" }; }

        var isForce = !!params.isForce;

        vm.entId(params.entId);
        vm.agentId(params.agentId);
        vm.agentNumber(params.agentNumber);
        vm.agentPassword(params.agentPassword);
        vm.forceLogin(isForce);

        socket.sendCommand({
            type : vm.forceLogin() ? commands.FORCE_LOGIN : commands.LOGIN,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                number : vm.agentNumber(),
                password : vm.agentPassword(),
                businessType: params && params.businessType,
                assistants:params && params.assistants
            }
        });

        vm.doingState(states.LOGINING);

        return { code : 0 };
    };

    extend.logout = function() {
        //if (!vm.logoutEnabled()) { return { code : -1, msg : "logout denied" }; }

        socket.sendCommand({
            type : commands.LOGOUT,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        vm.handlerLogout(true);

        return { code : 0 };
    };

    extend.setBusy = function(callback) {
        if (!vm.busyEnabled()) { return { code : -1, msg : "set busy denied" }; }

        socket.sendCommand({
            type : commands.SET_BUSY,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        if(typeof callback == "function") {
            handleEvent.setBusySuccessCallback(callback);
        }

        return { code : 0 };
    };
    
    extend.setWorking = function() {
        if (!vm.workingEnabled()) { return { code : -1, msg : "set working denied" }; }
        
        socket.sendCommand({
            type : commands.SET_WORKING,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });
        
        return { code : 0 };
    };
    
    extend.setAway = function(awayVaule) {
        if (!vm.awayEnabled()) { return { code : -1, msg : "set away denied" }; }

        if (!awayVaule) { return { code : -2, msg : "小休状态必选" }; }

        socket.sendCommand({
            type : commands.SET_AWAY,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                awayStatus: awayVaule
            }
        });

        return { code : 0 };
    };

    extend.setReady = function() {
        if (!vm.readyEnabled()) { return { code : -1, msg : "set ready denied" }; }
        if (!window.vm.setReadyEnabled()) { return { code : -2, msg : "当前文本会话数达到上限，不可置闲" }; }

        socket.sendCommand({
            type : commands.SET_READY,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    /**
     * 外呼号码保护
     * 手机号码中间四位数字处理为*，座机号码最后四位数字处理为*
     * @param outCallNumber
     */
    var numberProtection = function(outCallNumber) {
        var regExpMobile = new RegExp("^((9|90)?)1[0-9]{10}$");
        var regExpTel = new RegExp("([0-9]{3,4}-)?[0-9]{7,8}");

        if(regExpMobile.test(outCallNumber)) {
            outCallNumber = outCallNumber.substring(0, outCallNumber.length - 8) + "****" + outCallNumber.substring(outCallNumber.length - 4, outCallNumber.length);
            return outCallNumber;
        }

        if(regExpTel.test(outCallNumber)) {
            outCallNumber = outCallNumber.substring(0, outCallNumber.length - 4) + "****";

            return outCallNumber;
        }
    };

    extend.makeCall = function(params) {        

        if (!vm.callEnabled()) { return Promise.reject({ code : -1, msg : "make call denied" }); }

        params = params || {};
        if (!params.outCallNumber) { return  Promise.reject({ code : -2, msg : "呼叫号码必填" }); }

        if(params.isIntellectCall){
            params.disNumber = ""
        }else{
            if(!params.disNumber){
                return  Promise.reject({code: -2, msg: '没有可用的外显号码'})
            }
        }

        let promise = WebAgent.WaParams.callNumValidate && (typeof WebAgent.WaParams.callNumValidate == "function") ? WebAgent.WaParams.callNumValidate(params.outCallNumber):Promise.resolve();

        return promise.then(function(){
                    vm.numberProtection(params.numberProtection);  //设置外呼号码是否被保护

                    vm.callNumber(params.numberProtection ? numberProtection(params.outCallNumber):params.outCallNumber);   
                    
                    socket.sendCommand({
                        type : commands.MAKE_CALL,
                        entId : vm.entId(),
                        agentId : vm.agentId(),
                        ext : {
                            to : params.outCallNumber,
                            ani : params.disNumber,
                            uuid : params.uuid,        // 附加唯一标识
                            userData:params.userData,
                            mediaType:params.mediaType || "1",
                            ignoreTimeQuantumsCallLimit:params.ignoreTimeQuantumsCallLimit || "false"
                        }
                    });
            
                    return { code : 0 };
                }).catch(function(err){
                    return Promise.reject(err);
                })
    };

    /**
     * 扩展外呼接口
     *
     * 若当前状态可以外呼，则直接外呼
     * 若当前状态可以置忙，则置忙后外呼
     * 其他状态下此操作将被拒绝
     * @param params
     * @returns {*}
     */
    extend.makeCallExt = function(params) {
        var makeCall = function() {
            return extend.makeCall(params);
        };

        if (vm.callEnabled()) {
            return makeCall();
        }

        if (!vm.busyEnabled()) { return { code : -1, msg : "make call ext denied."}; }

        return extend.setBusy(makeCall);
    };

    extend.makeCallInternal = function(params) {
        if (!vm.callInternalEnabled()) { return { code : -1, msg : "make call internal denied" }; }

        params = params || {};
        if (!params.inCallNumber && !params.skillGroupName && !params.workStateAgentId) { return { code : -2, msg : "呼叫号码必填" }; }

        vm.callNumber(params.inCallNumber || params.workStateAgentId);

        socket.sendCommand({
            type : commands.MAKE_CALL_INTERNAL,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                agentId : params.workStateAgentId ? '' : vm.callNumber(),
                skillGroupName:params.skillGroupName || "",
                mediaType:params.mediaType || "",
                workStateAgentId:params.workStateAgentId || ""
            }
        });

        return { code : 0 };
    };

    extend.hangup = function() {
        if (!vm.hangupEnabled()) { return { code : -1, msg : "hangup denied" }; }

        socket.sendCommand({
            type : commands.HANGUP,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.reset = function() {
        if (!vm.resetEnabled()) { return { code : -1, msg : "reset denied" }; }

        socket.sendCommand({
            type : commands.RESET,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                state : null
            }
        });

        return { code : 0 };
    };

    extend.hold = function(params) {
        params = params || {};
        if(!params.isVideo && !vm.holdEnabled()){
            return { code : -1, msg : "hold denied" };
        }
        
        socket.sendCommand({
            type : commands.HOLD,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.holdReturn = function() {
        if (!vm.holdReturnEnabled()) { return { code : -1, msg : "hold return denied" }; }

        socket.sendCommand({
            type : commands.HOLD_RETURN,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.agentGetList = function(params) {
        socket.sendCommand({
            type : commands.AGENTGETLIST,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                workType : params
            }
        });

        return { code : 0 };
    }

    extend.consult = function(params) {
        if (!vm.consultEnabled()) { return { code : -1, msg : "consult denied" }; }

        params = params || {};
        if (!params.consultAgent) { return { code : -2, msg : "咨询号码必填" }; }
        if (!params.type) { return {code : -3, msg : "咨询类型必填" }; }

        socket.sendCommand({
            type : commands.CONSULT,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                to : params.consultAgent,
                type : params.type         // 1:内线咨询, 0:外线咨询
            }
        });
        return { code : 0 };
    };

    extend.consultReturn = function() {
        if (!vm.consultReturnEnabled()) { return { code : -1, msg : "consult return denied" }; }

        socket.sendCommand({
            type : commands.CONSULT_RETURN,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.transfer = function() {
        if (!vm.transferEnabled()) { return { code : -1, msg : "transfer denied" }; }

        socket.sendCommand({
            type : commands.TRANSFER,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.singleTransfer = function(params) {
        if (!vm.singleTransferEnabled()) { return { code : -1, msg : "single transfer denied" }; }

        params = params || {};
        if (!params.transferTo) { return { code : -2, msg : "转移号码必填" }; }
        if (!params.type) { return {code : -3, msg : "转移类型必填" }; }

        socket.sendCommand({
            type : commands.SINGLE_TRANSFER,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                to : params.transferTo,
                type : params.type    //1:单步转移内线，0:单步转移外线
            }
        });

        return { code : 0 };
    };

    extend.observe = function(params) {
        if (!vm.observeEnabled()) { return { code : -1, msg : "observe denied" }; }

        params = params || {};
        if (!params.observeAgentId) { return { code : -2, msg : "监听坐席必填" }; }

        socket.sendCommand({
            type : commands.OBSERVE,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                agentId : params.observeAgentId
            }
        });

        return { code : 0 };
    };


    /**
     * 扩展监听接口
     *
     * 若当前状态可以监听，则直接监听
     * 若当前状态可以置忙，则置忙后监听
     * 其他状态下此操作将被拒绝
     * @param params
     * @returns {*}
     */
    extend.observeExt = function(params) {
        var observe = function() {
            return extend.observe(params);
        };

        if (vm.observeEnabled()) {
            return observe();
        }

        if (!vm.busyEnabled()) { return { code : -1, msg : "observe ext denied."}; }

        return extend.setBusy(observe);
    };


    extend.forceInsert = function() {
        if (!vm.insertEnabled()) { return { code : -1, msg : "force insert denied" }; }

        socket.sendCommand({
            type : commands.FORCE_INSERT,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.forceAbort = function() {
        if (!vm.forceAbortEnabled()) { return { code : -1, msg : "force abort denied" }; }

        socket.sendCommand({
            type : commands.FORCE_ABORT,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.fullAbort = function() {
        if (!vm.fullAbortEnabled()) { return { code : -1, msg : "full abort denied" }; }

        socket.sendCommand({
            type : commands.FULL_ABORT,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    extend.conference = function() {
        if (!vm.conferenceEnabled()) { return { code : -1, msg : "conference denied" }; }

        socket.sendCommand({
            type : commands.CONFERENCE,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });

        return { code : 0 };
    };

    /**
     * 单步会议
     * @returns {{msg: string, code: number}|{code: number}}
     */
    extend.singleConference = function(params) {
        if (!vm.singleConferenceEnabled()) { return { code : -1, msg : "single conference denied" }; }

        params = params || {};
        if (!params.transferTo) { return { code : -2, msg : "会议呼叫信息必填" }; }
        if (!params.type) { return {code : -3, msg : "会议呼叫类型必填" }; }

        socket.sendCommand({
            type : commands.SINGLE_CONFERENCE,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                to : params.transferTo,
                type : params.type    //1:会议呼叫内线，0:会议呼叫外线，2:会议呼叫技能组，4:工作态坐席
            }
        });

        return { code : 0 };
    };

    extend.assistIVR = function(params) {
        if (!vm.assistIVREnabled()) { return { code : -1, msg : "assist IVR denied" }; }

        params = params || {};
        var callDataKey = params.key || "";
        var callDataValue = params.value || "";
        var checkIvrCardIdType = params.type;
        var ivrAssistsCardId= params.cardId || "";

       Log.log("params:",callDataValue+";type="+checkIvrCardIdType+";cardId="+ivrAssistsCardId);

        socket.sendCommand({
            type : commands.ASSIST_IVR,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                key:callDataKey,
                value:callDataValue+";type="+checkIvrCardIdType+";cardId="+ivrAssistsCardId
            }
        });

        return { code : 0 };
    };

    //extend.routerToIVR = function(params) {
    //    if (!vm.routerToIVREnabled()) { return { code : -1, msg : "router to IVR denied" }; }
    //
    //    params = params || {};
    //    var callDataKey = params.key || "SD";
    //    var callDataValue = params.value || "";
    //
    //    socket.sendCommand({
    //        type : commands.ROUTER_TO_IVR,
    //        entId : vm.entId(),
    //        agentId : vm.agentId(),
    //        ext : {
    //            key : callDataKey,
    //            value : callDataValue
    //        }
    //    });
    //
    //    return { code : 0 };
    //};

    extend.routerToIVR = function(param) {
        if (!vm.routerToIVREnabled()) { return { code : -1, msg : "router to IVR denied" }; }

        var callDataValue = param;

        socket.sendCommand({
            type : commands.ROUTER_TO_IVR,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                param : callDataValue
            }
        });

        return { code : 0 };
    };

    extend.setCallData = function(params) {
        if (!vm.setCallDataEnabled()) { return { code : -1, msg : "set call data denied" }; }

        params = params || {};
        var callDataKey = params.key || "";
        var callDataValue = params.value || "";

        socket.sendCommand({
            type : commands.SET_CALL_DATA,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                key : callDataKey,
                value : callDataValue
            }
        });

        return { code : 0 };
    };

    extend.getCallData = function(key, callback) {
        if (!vm.getCallDataEnabled()) { return { code : -1, msg : "get call data denied" }; }

        //if (!key) { return { code : -2, msg : "随路数据key必填" }; }

        socket.sendCommand({
            type : commands.GET_CALL_DATA,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                key : key || ""
            }
        });

        if (typeof callback === "function") {
            handleEvent.setGetCallDataCallback(callback);
        }

        return { code : 0 };
    };

    extend.pushVideo = function(params){
        if (!vm.holdEnabled()) { return { code : -1, msg : "hold denied" }; }

        if(!params){
            return  { code : -2, msg : "视频推送地址必填" }
        }
        socket.sendCommand({
            type : commands.PUSH_VIDEO,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                file:params.url
            }
        });

        return { code : 0 };
    }

    extend.sendDTMF = function(dtmf) {

        var regex = /^([0-9\#\*])+$/g; //匹配0-9*#

        if (!vm.sendDTMFEnabled()) { return { code : -1, msg : "send DTMF denied" }; }
        if (!dtmf) { return { code : -2, msg : "二次拨号号码不能为空" }; }
        if(!regex.test(dtmf)) {return {code : -2, msg : "二次拨号号码不合法，需由0123456789*#组成"};}

        socket.sendCommand({
            type : commands.SECOND_CALL,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                secondNum : dtmf
            }
        });

        return { code : 0 };
    };
    
    extend.joinConference = function(params) {
        if (!vm.joinConferenceEnabled()) { return { code : -1, msg : "Join ConferencmakeCalle denied" }; }
    
        params = params || {};
        if (!params.consultAgent) { return { code : -2, msg : "加入会议号码必填" }; }
        if (!params.type) { return {code : -3, msg : "加入会议类型必填" }; }
    
        socket.sendCommand({
            type : commands.JOIN_CONFERENCE,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                to : params.consultAgent,
                type : params.type         // 1:内线咨询, 0:外线咨询 2:会议呼叫技能组，4:工作态坐席
            }
        });
        return { code : 0 };
    };
    
    /**
     * 拦截坐席
     * @param params
     * @returns {{msg: string, code: number}|{code: number}}
     */
    extend.intercept = function(params) {
        if (!vm.observeEnabled()) { return { code : -1, msg : "intercept denied" }; }
        
        params = params || {};
        if (!params.observeAgentId) { return { code : -2, msg : "拦截坐席必填" }; }
        
        socket.sendCommand({
            type : commands.INTERCEPT,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                destAgentId : params.observeAgentId
            }
        });
        
        return { code : 0 };
    };
    
    /**
     * 开启密语
     * @param params
     * @returns {{msg: string, code: number}|{code: number}}
     */
    extend.startCrypto = function(params) {
        if (!vm.startCryptolaliaEnabled()) { return { code : -1, msg : "start cryptolalia denied" }; }
        
        socket.sendCommand({
            type : commands.START_CRYPTO,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });
        return { code : 0 };
    };
    
    /**
     * 开启密语
     * @param params
     * @returns {{msg: string, code: number}|{code: number}}
     */
    extend.stopCrypto = function(params) {
        if (!vm.stopCryptolaliaEnabled()) { return { code : -1, msg : "stop cryptolalia denied" }; }
        
        socket.sendCommand({
            type : commands.STOP_CRYPTO,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {}
        });
        return { code : 0 };
    };
    
    /**
     * 切换技能组
     */
    extend.switchSkillGroup = function (params) {
        console.log(params,'params');
        if(!params.skillGroupList){ return { code : -1, msg : "请至少选择一个技能组！" }; }
        
        socket.sendCommand({
            type : commands.SWITCH_SKILL_GROUP,
            entId : vm.entId(),
            agentId : vm.agentId(),
            ext : {
                skillGroupList: params.skillGroupList
            }
        });
        return { code : 0 };
    }

    return extend;
});

/**
 * Created by mengchen on 2015/12/9.
 */
(function(baseUrl, initParams, urlArgs) {
    "use strict";

    requirejs.config({
        urlArgs: urlArgs,
        baseUrl: baseUrl,
        paths: {
            "jquery"           : "MultiChannel/windowJquery",
            "wa_io"        : "WA/lib/netty-socket.io",
            //"wa_colorBlink": "WA/lib/colorBlink",
            "wa_json"      : "WA/lib/json",
            "area_code"      : "WA/lib/area-code",
            "font"         : "public_css/font-awesome.min",
            "style"        : "WA/css/WA",
            "wa_dom"       : "WA/app/WA-ui.html",

            "wa_Defaults"           : "WA/app/Defaults",
            "wa_Constant"           : "WA/app/Constant",
            "wa_Counter"            : "WA/app/Counter",
            "wa_Log"                : "WA/app/Log",
            "wa_Socket"             : "WA/app/Socket",
            "wa_Extend"             : "WA/app/Extend",
            "wa_ViewModel"          : "WA/app/ViewModel",
            "wa_Vm"                 : "WA/app/Vm",
            "wa_CheckInit"          : "WA/app/CheckInit",
            "wa_RegisterHandler"    : "WA/app/RegisterHandler",
            "wa_Tip"                : "WA/app/Tip",
            "wa_HandleEvent"        : "WA/app/HandleEvent",
            "wa_HandleCommandResult": "WA/app/HandleCommandResult",
            "wa_Storage"            : "WA/app/Storage",
            "dialog"                : "WA/app/Dialog",
            "ButelAjax"             : "MultiChannel/ButelAjax",
            "HRCookie"              : "WA/app/HRCookie",
            "RobotAgent"            : "WA/app/RobotAgent",
            "Utils"             : "MultiChannel/utils",
        }
    });

    require(["jquery", "wa_Defaults", "wa_Socket", "wa_Extend", "wa_RegisterHandler", "wa_CheckInit", "wa_Vm", "wa_Counter"], function($, defaults, socket,extend, registerHandler, checkInit, vm, counter) {
        "use strict";
        initParams = initParams || {};

        var ui = initParams.ui || !("ui" in initParams);
        var sipUseCphone = initParams.sipUseCphone || !("sipUseCphone" in initParams);
        var connect = initParams.connect || !("connect" in initParams);
        var right = typeof initParams.position == "object" && typeof initParams.position.right == "number" ? initParams.position.right : defaults.iconRight;
        var bottom = typeof initParams.position == "object" && typeof initParams.position.bottom == "number" ? initParams.position.bottom : defaults.iconBottom;
        var visible = initParams.visible || !("visible" in initParams);
        var colorObj = initParams.colorObj;
        var interval = initParams.interval;
        var loginInfo = initParams.loginInfo || {};
        var entId = loginInfo.entId || {};
        var agentId = loginInfo.agentId || {};
        var agentPassword = loginInfo.agentPassword || {};
        var agentNumber = loginInfo.agentNumber || {};
        var selectorName = initParams.selectorName;
        var outNumbersVisible = initParams.outNumbersVisible || !("outNumbersVisible" in initParams);

        //var $ = $.noConflict(true);

        if (typeof initParams.callback === "function") {
            checkInit.initSuccessCallback(initParams.callback);
        }

        //设置登录信息
        vm.entId(entId.value);
        vm.agentId(agentId.value);
        vm.agentPassword(agentPassword.value);
        vm.agentNumber(agentNumber.value);

        vm.sipUseCphone(sipUseCphone);

        //是否使用面板
        vm.ui(ui);

        // 设置计数器的输出持有者
        counter.valueHolder(vm.callDuration);

        connect && socket.initSocket();

        WebAgent.vm = vm;
        WebAgent.WaParams = initParams;
        WebAgent.extend = extend;
        WebAgent.registerEventHandler = registerHandler.registerEventHandler;
        WebAgent.registerStateListener = registerHandler.registerStateListener;
        WebAgent.registerResultHandler = registerHandler.registerResultHandler;
        WebAgent.removeEventHandler = registerHandler.removeEventHandler;
        WebAgent.removeResultHandler = registerHandler.removeResultHandler;

        if (!ui) {
            checkInit.setInitUISuccess().checkInitSuccess();
            return;
        }

        require(["text!wa_dom", "knockout", "css!style"],function(dom, ko){
            $(selectorName || document.body).append(dom);

            // 设置电话图标的位置
            //vm.icon_posRight(right + 'px');
            //vm.icon_posBottom(bottom + 'px');

            // 设置WA_div的位置
            //vm.div_posRight(right + defaults.relativeRight + 'px');
            //vm.div_posBottom(bottom + defaults.relativeBottom + 'px');

            vm.div_posRight(right + 'px');
            vm.div_posBottom(bottom + 'px');

            //设置软电话登录界面是否展示
            vm.div_visible(visible);

            //获取设置电话图标的颜色和颜色变化的时间间隔
            vm.colorObj(colorObj);
            vm.icon_interval(interval);

            //设置登录信息是否只读
            vm.entIdReadonly(Boolean(entId.readonly));
            vm.agentIdReadonly(Boolean(agentId.readonly));
            vm.agentPasswordReadonly(Boolean(agentPassword.readonly));
            vm.agentNumberReadonly(Boolean(agentNumber.readonly));

            //设置外显号是否展示
            vm.outNumbersVisible(outNumbersVisible);

            ko.applyBindings(vm, document.getElementById("WA"));
            document.getElementById("WA").style.display = "block";

            // 绑定事件
            //initEventBind($);

            //界面显示、隐藏切换
            WebAgent.WaToggle = function() {
                $("#WA-div").toggle();
            };

            checkInit.setInitUISuccess().checkInitSuccess();
        });
    });
    //
    //var initEventBind = function($) {
    //    $(function() {
    //        var $waDiv = $("#WA-div");
    //        $("#WA-icon").bind("click", function() {
    //            if ($waDiv.is(":hidden")) {
    //                $waDiv.css("width", 0).show().animate({width: 330});
    //            } else {
    //                $waDiv.animate({width: 0}, function() {
    //                    $(this).hide();
    //                });
    //            }
    //        });
    //    });
    //};

})(WebAgent.baseUrl, WebAgent.WaParams, WebAgent.urlArgs);

define("main", function(){});

